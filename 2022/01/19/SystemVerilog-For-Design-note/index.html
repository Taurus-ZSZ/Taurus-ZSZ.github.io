<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="systemverilog  for design 学习笔记Prefacesystem verilog 相对于verilog 的扩展从广义上来说可以分为两个主要的分类：  增强主要解决硬件建模的需求，包括整体效率和抽象级别。 增强验证和断言 对于超大型复杂设计测试平台的高效编写  对于使用system Verilog 进行HDL 设计可以参考本书《system Verilog for design">
<meta property="og:type" content="article">
<meta property="og:title" content="SystemVerilog_For_Design_note">
<meta property="og:url" content="http://example.com/2022/01/19/SystemVerilog-For-Design-note/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="systemverilog  for design 学习笔记Prefacesystem verilog 相对于verilog 的扩展从广义上来说可以分为两个主要的分类：  增强主要解决硬件建模的需求，包括整体效率和抽象级别。 增强验证和断言 对于超大型复杂设计测试平台的高效编写  对于使用system Verilog 进行HDL 设计可以参考本书《system Verilog for design">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/01/19/SystemVerilog-For-Design-note/image-20220203152443820.png">
<meta property="article:published_time" content="2022-01-18T21:46:01.000Z">
<meta property="article:modified_time" content="2022-02-04T08:59:47.000Z">
<meta property="article:author" content="zsz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/19/SystemVerilog-For-Design-note/image-20220203152443820.png">


<link rel="canonical" href="http://example.com/2022/01/19/SystemVerilog-For-Design-note/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/01/19/SystemVerilog-For-Design-note/","path":"2022/01/19/SystemVerilog-For-Design-note/","title":"SystemVerilog_For_Design_note"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SystemVerilog_For_Design_note | Hexo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">遇见美好的每天</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">21</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#systemverilog-for-design-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">systemverilog  for design 学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preface"><span class="nav-number">1.1.</span> <span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-system-Verilog-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.</span> <span class="nav-text">第一章 system Verilog 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#package-definitions"><span class="nav-number">1.3.1.</span> <span class="nav-text">package definitions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="nav-number">1.4.</span> <span class="nav-text">第三章</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-System-Verilog-%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.3 System Verilog 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#system-Verilog-data-types"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">system Verilog data types</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SystemVerilog-4-state-variables"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">SystemVerilog 4-state variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SystemVerilog-2-state-variables"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">SystemVerilog 2-state variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#simulation"><span class="nav-number">1.4.1.1.3.</span> <span class="nav-text">simulation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Explicit-and-implicit-variable-and-net-data-types"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Explicit and implicit variable and net data types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">综合指南</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SystemVerilog-relaxes-restrictions-on-using-variables"><span class="nav-number">1.4.2.</span> <span class="nav-text">SystemVerilog relaxes restrictions on using variables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">错误的使用情况：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system-verilog-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">system verilog 使用变量的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signed-and-unsigned-modifiers"><span class="nav-number">1.4.4.</span> <span class="nav-text">Signed and unsigned modifiers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.5.</span> <span class="nav-text">3.9 数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">静态编译时强制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97-1"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">综合指南</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.6.</span> <span class="nav-text">3.10 常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-User-Defined-and-Enumerated-Types"><span class="nav-number">1.5.</span> <span class="nav-text">第四章 User-Defined and Enumerated Types</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-User-defined-types"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 User-defined types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Local-typedef-definitions"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Local typedef definitions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shared-typedef-definitions"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Shared typedef definitions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#typedef-definitions-in-packages"><span class="nav-number">1.5.1.2.1.</span> <span class="nav-text">typedef definitions in packages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#typedef-definitions-in-unit"><span class="nav-number">1.5.1.2.2.</span> <span class="nav-text">typedef definitions in  $unit</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user-defined-types-%E5%91%BD%E5%90%8D%E6%83%AF%E4%BE%8B"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">user-defined types 命名惯例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enumerated-types-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.2.</span> <span class="nav-text">Enumerated types 枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Importing-enumerated-types-from-packages"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Importing enumerated types from packages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enumerated-type-label-sequences"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Enumerated type label sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enumerated-labels-must-be-unique"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">enumerated labels must be unique</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enumerated-type-values"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">Enumerated type values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Etype-%E7%9A%84%E6%9E%9A%E4%B8%BE%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">基于type 的枚举体类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E4%B8%BAtypedef"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">枚举类型可以声明为typedef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">枚举类型的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">将表达式转换为枚举类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">打印枚举类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-SystemVerilog-Arrays-Structures-and-Unions"><span class="nav-number">1.6.</span> <span class="nav-text">第五章 SystemVerilog Arrays,Structures and Unions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Structures-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 Structures 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Structure-declartions"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">Structure declartions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#structures-can-be-user-defined-types"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">structures can be user-defined types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A-using-packages-or-unit"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">共享结构体的定义： using packages or $unit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">结构体赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.6.1.4.1.</span> <span class="nav-text">初始化结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.1.4.2.</span> <span class="nav-text">结构体成员赋值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">打包和解包结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%BB%93%E6%9E%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.1.5.1.</span> <span class="nav-text">包装结构的操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#signed-packed-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.6.1.5.2.</span> <span class="nav-text">signed packed 结构体</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%AB%AF%E5%8F%A3%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">通过端口传递结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.1.7.</span> <span class="nav-text">将结构作为参数传递给任务和函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97-2"><span class="nav-number">1.6.1.8.</span> <span class="nav-text">综合指南</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2Unions-%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2Unions 联合体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unpacked-unions"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Unpacked unions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Packed-unions"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Packed unions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#An-example-of-using-structures-and-unions"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">An example of using structures and unions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Arrays"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3 Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unpacked-arrays"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">unpacked arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Packed-arrays"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">Packed arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%89%93%E5%8C%85%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">引用打包数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-packed-and-unpacked-arrays"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">Using packed and unpacked arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">声明数组时初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Packed-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.6.3.4.1.</span> <span class="nav-text">Packed 数组初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unpacked-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.6.3.4.2.</span> <span class="nav-text">Unpacked 数组初始化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">数组赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Unpacked-arrays-%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.3.5.1.</span> <span class="nav-text">Unpacked arrays 赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Packed-arrays-%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.3.5.2.</span> <span class="nav-text">Packed arrays 赋值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6"><span class="nav-number">1.6.3.6.</span> <span class="nav-text">数组复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.3.7.</span> <span class="nav-text">将用户定义的类型与数组一起使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97-3"><span class="nav-number">1.6.3.8.</span> <span class="nav-text">综合指南</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.6.3.9.</span> <span class="nav-text">使用数组的示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach-%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.4.</span> <span class="nav-text">foreach 数组循环结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-SystemVerilog-%E7%A8%8B%E5%BA%8F%E5%9D%97%E3%80%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">第六章 SystemVerilog 程序块、任务和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Verilog-%E4%B8%AD%E7%9A%84always%E5%9D%97"><span class="nav-number">1.7.1.</span> <span class="nav-text">Verilog 中的always块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system-verilog-%E4%B8%AD%E7%9A%84-procedural-block"><span class="nav-number">1.7.2.</span> <span class="nav-text">system verilog 中的  procedural  block</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#always-comb"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">always_comb</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#always-ff"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">always_ff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#always-latch"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">always_latch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97-4"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">综合指南</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84tasks-%E4%B8%8E-functions"><span class="nav-number">1.7.3.</span> <span class="nav-text">增强的tasks 与 functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0%E8%AF%AD%E5%8F%A5%E7%BB%84"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">隐式的任务和函数语句组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">函数返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E7%BB%93%E6%9D%9F%E5%89%8D%E8%BF%94%E5%9B%9E"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">在任务和功能结束前返回</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-system-Verilog-Interfaces"><span class="nav-number">1.8.</span> <span class="nav-text">第十章 system Verilog Interfaces</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.8.1.</span> <span class="nav-text">接口概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Verilog%E6%A8%A1%E5%9D%97%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">Verilog模块端口的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SystemVerilog-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">SystemVerilog 接口的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SystemVerilog-interface-%E5%86%85%E5%AE%B9"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">SystemVerilog interface 内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">模块和接口的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="nav-number">1.8.2.</span> <span class="nav-text">接口声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">源代码声明顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">全局和本地接口定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9D%97%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.8.3.</span> <span class="nav-text">使用接口作为模块端口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%91%BD%E5%90%8D%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">显式命名的接口端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">通用接口端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97-5"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">综合指南</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.8.4.</span> <span class="nav-text">实例化和连接接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E5%86%85%E5%BC%95%E7%94%A8%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.8.5.</span> <span class="nav-text">在接口内引用信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface-modports"><span class="nav-number">1.8.6.</span> <span class="nav-text">Interface modports</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84-modport-%E8%A7%86%E5%9B%BE"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">指定要使用的 modport 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B%E4%B8%AD%E9%80%89%E6%8B%A9-modport"><span class="nav-number">1.8.6.1.1.</span> <span class="nav-text">在模块实例中选择 modport</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%AB%AF%E5%8F%A3%E5%A3%B0%E6%98%8E%E4%B8%AD%E9%80%89%E6%8B%A9-modport"><span class="nav-number">1.8.6.1.2.</span> <span class="nav-text">在模块端口声明中选择 modport</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zsz</p>
  <div class="site-description" itemprop="description">不负光阴韶华</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/19/SystemVerilog-For-Design-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsz">
      <meta itemprop="description" content="不负光阴韶华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SystemVerilog_For_Design_note
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-19 05:46:01" itemprop="dateCreated datePublished" datetime="2022-01-19T05:46:01+08:00">2022-01-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-04 16:59:47" itemprop="dateModified" datetime="2022-02-04T16:59:47+08:00">2022-02-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="systemverilog-for-design-学习笔记"><a href="#systemverilog-for-design-学习笔记" class="headerlink" title="systemverilog  for design 学习笔记"></a>systemverilog  for design 学习笔记</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>system verilog 相对于verilog 的扩展从广义上来说可以分为两个主要的分类：</p>
<ul>
<li>增强主要解决硬件建模的需求，包括整体效率和抽象级别。</li>
<li>增强验证和断言 对于超大型复杂设计测试平台的高效编写</li>
</ul>
<p>对于使用system Verilog 进行HDL 设计可以参考本书《system Verilog for design》，对于验证方面的书可以参考“SystemVerilog for Verification”。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>什么是单文件编译？什么是多文件编译？？？</li>
<li>第三章中的3.2节没有搞明白，system Verilog 中对于`define 的增强。？？？</li>
<li>在verilog 中的$signed() 与 $unsigned() 可以被综合吗？？？？</li>
<li>fpga 中锁存器的影响，什么是锁存器</li>
</ol>
<h2 id="第一章-system-Verilog-简介"><a href="#第一章-system-Verilog-简介" class="headerlink" title="第一章 system Verilog 简介"></a>第一章 system Verilog 简介</h2><h3 id="package-definitions"><a href="#package-definitions" class="headerlink" title="package definitions"></a>package definitions</h3><p>Example 2-1: A package definition</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line"><span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">opcodes_t opcode;</span><br><span class="line">&#125; instruction_t;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a, b);</span><br><span class="line"><span class="comment">// code for a custom 32-bit multiplier goes here</span></span><br><span class="line"><span class="keyword">return</span> a * b; <span class="comment">// abstract multiplier (no error detection)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>



<p>Example 2-2: Explicit package references using the :: scope resolution operator</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU</span><br><span class="line">(<span class="keyword">input</span> definitions::instruction_t IW,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (IW<span class="variable">.opcode</span>)</span><br><span class="line">definitions::ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>;</span><br><span class="line">definitions::SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>;</span><br><span class="line">definitions::MUL : result = definitions::</span><br><span class="line">multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>);</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<p>Example 2-3: Importing specific package items into a module</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU</span><br><span class="line">(<span class="keyword">input</span> definitions::instruction_t IW,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> definitions::ADD;</span><br><span class="line"><span class="keyword">import</span> definitions::SUB;</span><br><span class="line"><span class="keyword">import</span> definitions::MUL;</span><br><span class="line"><span class="keyword">import</span> definitions::multiplier;</span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span> (IW<span class="variable">.opcode</span>)</span><br><span class="line">ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>;</span><br><span class="line">SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>;</span><br><span class="line">MUL : result = multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>);</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<p>Example 2-4: Using a package wildcard import</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU</span><br><span class="line">(<span class="keyword">input</span> definitions::instruction_t IW,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"><span class="keyword">import</span> definitions::*; <span class="comment">// wildcard import</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span> (IW<span class="variable">.opcode</span>)</span><br><span class="line">ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>;</span><br><span class="line">SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>;</span><br><span class="line">MUL : result = multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>);</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>system Verilog允许使用时间单位作为时间的一部分比如：</p>
<p>在verilog中使用`timescale  编译器指令将时间单位指定为软件工具的命令  。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生一个周期为10ns的时钟：</span></span><br><span class="line"><span class="keyword">forever</span> #<span class="number">5</span>ns clock = ~clock;</span><br></pre></td></tr></table></figure>



<p>Mixed declarations of time units and precision (not synthesizable)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">timeunit</span> <span class="number">1</span>ns; <span class="comment">// external time unit and precision</span></span><br><span class="line"><span class="keyword">timeprecision</span> <span class="number">1</span>ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> my_chip ( ... ); </span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps; <span class="comment">// local precision (priority over external)</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> data_request) <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">2</span><span class="variable">.5</span> send_packet; <span class="comment">// uses external units &amp; local precision</span></span><br><span class="line">        #<span class="number">3</span><span class="variable">.75ns</span> check_crc; <span class="comment">// specific units take precedence</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">task</span> send_packet();</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	<span class="keyword">task</span> check_crc();</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ps/1ps // directive takes precedence over external</span></span><br><span class="line"><span class="keyword">module</span> FSM ( ... );</span><br><span class="line">	<span class="keyword">timeunit</span> <span class="number">1</span>ns; <span class="comment">// local units take priority over directive</span></span><br><span class="line">    <span class="keyword">always</span> @(State) <span class="keyword">begin</span></span><br><span class="line">    	#<span class="number">1</span><span class="variable">.2</span> <span class="keyword">case</span> (State) <span class="comment">// uses local units &amp; timescale precision</span></span><br><span class="line">    	WAITE: #<span class="number">20</span>ps ...; <span class="comment">// specific units take precedence</span></span><br><span class="line">    	...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>







<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-3-System-Verilog-变量"><a href="#3-3-System-Verilog-变量" class="headerlink" title="3.3 System Verilog 变量"></a>3.3 System Verilog 变量</h3><p>在system Verilog中分为类型与数据类型：</p>
<p><strong>type：</strong> variable types,net types</p>
<p><strong>data type：</strong> 4state(logic) 2state(bit)</p>
<p>verilog 数据类型：variable type, net type</p>
<p>variable types：reg ，integer，time 都是4值类型</p>
<p>net types: wire,wor,wand etc也都是4值类型，但是每种值都有120个强度等级。</p>
<h4 id="system-Verilog-data-types"><a href="#system-Verilog-data-types" class="headerlink" title="system Verilog data types"></a>system Verilog data types</h4><p><strong>Type</strong> indicates if the signal is a net or variable. system verilog 使用了所有的verilog 变量类型，像 <strong>reg</strong></p>
<p>, <strong>integer</strong> ,并且添加了几个variable types 像byte,int 等。在System verilog 中，并没有扩展verilog 的 net types.</p>
<p><strong>Data type</strong> indicates the value system of the net or variable, which is 0 or 1 for 2-state data types, and 0, 1, Z or X for 4-state data types.System Verilog 使用关键字 <strong>bit</strong> 定义2 state date types;使用关键字<strong>logic</strong> 定义4state data types。变量可以是2 state 或者是4 state ,而net 只能是4 state。 </p>
<h5 id="SystemVerilog-4-state-variables"><a href="#SystemVerilog-4-state-variables" class="headerlink" title="SystemVerilog 4-state variables"></a>SystemVerilog 4-state variables</h5><p>variable type:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式表示4state 变量 与verilog 中的reg 等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> resetN; <span class="comment">// a 1-bit wide 4-state variable</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data; <span class="comment">// a 64-bit wide variable</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">0</span>:<span class="number">7</span>] array [<span class="number">0</span>:<span class="number">255</span>]; <span class="comment">// an array of 8-bit variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//明确的表示 variable </span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;<span class="comment">// a 64-bit wide variable</span></span><br></pre></td></tr></table></figure>

<p>net type:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data; <span class="comment">// a 64-bit wide net</span></span><br></pre></td></tr></table></figure>



<h5 id="SystemVerilog-2-state-variables"><a href="#SystemVerilog-2-state-variables" class="headerlink" title="SystemVerilog 2-state variables"></a>SystemVerilog 2-state variables</h5><ul>
<li> bit — a 1-bit 2-state integer</li>
<li> byte — an 8-bit 2-state integer, similar to a C char</li>
<li> shortint — a 16-bit 2-state integer, similar to a C short</li>
<li> int — a 32-bit 2-state integer, similar to a C int</li>
<li> longint — a 64-bit 2-state integer, similar to a C longlong</li>
</ul>
<p>The  keyword  bit  is  not  actually  a  variable  type,  it  is  a  data  type, indicating the variable can have 2-state values.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式表示</span></span><br><span class="line"><span class="keyword">bit</span> resetN; <span class="comment">// a 1-bit wide 2-state variable</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">63</span>:<span class="number">0</span>] data; <span class="comment">// a 64-bit 2-state variable</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">7</span>] array [<span class="number">0</span>:<span class="number">255</span>]; <span class="comment">// an array of 8-bit 2-state variables</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//明确的表示 variable </span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">bit</span> [<span class="number">63</span>:<span class="number">0</span>] addr; <span class="comment">// a 64-bit wide variable</span></span><br></pre></td></tr></table></figure>



<h5 id="simulation"><a href="#simulation" class="headerlink" title="simulation"></a>simulation</h5><p>在仿真中，4 state types 的默认值是X;2-state types 的默认值是0。</p>
<p>当4-state types 转换成2-state types时，X,Z将被映射成0。</p>
<h4 id="Explicit-and-implicit-variable-and-net-data-types"><a href="#Explicit-and-implicit-variable-and-net-data-types" class="headerlink" title="Explicit and implicit variable and net data types"></a>Explicit and implicit variable and net data types</h4><p>在system verilog 中关键字<strong>logic</strong> 表示4-state data type，关键字<strong>bit</strong>表示2-state data type。当使用这些 4 状态或 2 状态数据类型而没有明确指定数据类型是<strong>variable</strong>或<strong>net</strong>时，会推断出隐式<strong>variable</strong>。</p>
<p>example：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] busA; 	<span class="comment">// infers a variable that is</span></span><br><span class="line">					<span class="comment">// a 4-state data type</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] busB; 	<span class="comment">// infers a variable that is</span></span><br><span class="line">					<span class="comment">// a 2-state data type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显式定义：</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a; <span class="comment">// 4-state 8-bit variable</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] b; <span class="comment">// 2-state 32-bit variable</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">int</span> i; <span class="comment">// 2-state 32-bit variable</span></span><br></pre></td></tr></table></figure>

<p>var 关键字不影响变量在仿真或综合中的行为方式。它的用途是帮助使代码更加自文档化。当从用户定义的类型创建变量时，此明确的文档可以帮助使代码更具可读性和可维护性。例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">bit</span> &#123;FALSE, TRUE&#125; bool_t;</span><br><span class="line"><span class="keyword">var</span> bool_t c; <span class="comment">// variable of user-defined type</span></span><br></pre></td></tr></table></figure>



<p>可选地，可以使用网络类型和逻辑数据类型来声明网络：wire logic [31:0] busC;</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>  [<span class="number">31</span>:<span class="number">0</span>] busC;</span><br><span class="line"><span class="keyword">wire</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] busC;</span><br></pre></td></tr></table></figure>

<h4 id="综合指南"><a href="#综合指南" class="headerlink" title="综合指南"></a>综合指南</h4><p>2-state types synthesize the same as 4-state types</p>
<p>4 状态逻辑类型和 2 状态位、字节、shortint、int 和 longint 类型是可综合的。综合编译器以相同的方式处理 2-state 和 4-state 类型。 2 态类型的使用主要影响仿真。</p>
<p>synthesis ignores the default initial value of 2-state types</p>
<p>2 状态类型以逻辑值 0 的默认值开始仿真。综合忽略此默认初始值。通过综合实现的综合后设计不能保证以零上电，就像使用 2 态类型的综合前模型上电时一样。</p>
<h3 id="SystemVerilog-relaxes-restrictions-on-using-variables"><a href="#SystemVerilog-relaxes-restrictions-on-using-variables" class="headerlink" title="SystemVerilog relaxes restrictions on using variables"></a>SystemVerilog relaxes restrictions on using variables</h3><p>SystemVerilog 通过放宽可以使用变量的规则，极大地简化了确定模型中使用的正确类型的过程。使用 SystemVerilog，变量可以通过以下任何一种方式接收值，但不能超过以下一种方式（意思是不可以多重驱动同一个变量）：</p>
<ul>
<li>Be  assigned  a  value  from  any  number  of  initial  or  always procedural blocks (the same rule as in Verilog). </li>
<li> Be assigned a value from a single always_comb, always_ff or always_latch  procedural  block.  These  SystemVerilog  proce- dural blocks are discussed in Chapter 6.</li>
<li> Be  assigned  a  value  from  a  single  continuous  assignment  state-ment.</li>
<li> Receive a value from a single module or primitive output or inout port.</li>
</ul>
<p><strong>example:</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> compare (<span class="keyword">output</span> <span class="keyword">logic</span> lt, eq, gt,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] a, b );</span><br><span class="line"><span class="keyword">always</span> @(a, b)</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) </span><br><span class="line">        lt = <span class="number">1&#x27;b1</span>; <span class="comment">// procedural assignments</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        lt = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">assign</span> gt = (a &gt; b); <span class="comment">// continuous assignments</span></span><br><span class="line">	comparator u1 (eq, a, b); <span class="comment">// module instance</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> comparator (<span class="keyword">output</span> <span class="keyword">logic</span> eq,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>] a, b);</span><br><span class="line"><span class="keyword">always</span> @(a, b)</span><br><span class="line">	eq = (a==b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="错误的使用情况："><a href="#错误的使用情况：" class="headerlink" title="错误的使用情况："></a>错误的使用情况：</h4><p><strong>Restrictions on variables can prevent design errors</strong></p>
<p><strong>Variables cannot be driven by multiple sources.</strong></p>
<h3 id="system-verilog-使用变量的限制"><a href="#system-verilog-使用变量的限制" class="headerlink" title="system verilog 使用变量的限制"></a>system verilog 使用变量的限制</h3><p>需要注意的是，虽然 SystemVerilog 允许在 Verilog 不允许的地方使用变量，但 SystemVerilog 对变量的使用仍然有一些限制。 </p>
<p>SystemVerilog 将多个输出端口或多个连续赋值写入同一个变量，或者将过程赋值与连续赋值或输出驱动程序组合在同一个变量上会导致错误。</p>
<p>这些限制的原因是当两个或多个设备驱动相同的输出时，变量没有内置的解析功能来解析最终值。只有 Verilog 网络类型，例如wire、wand (wire-and) 和 wor (wire-or)，具有内置解析函数来解析多驱动器逻辑。 （Verilog-2005 标准也有一个 uwire 网络类型，它将其使用限制为单个驱动程序，与变量相同。）</p>
<p>错误的使用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add_and_increment (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] sum,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">logic</span> carry,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] a, b </span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(a, b)</span><br><span class="line">	sum = a + b; <span class="comment">// procedural assignment to sum</span></span><br><span class="line"><span class="keyword">assign</span> sum = sum + <span class="number">1</span>; <span class="comment">// ERROR! sum is already being</span></span><br><span class="line"><span class="comment">// assigned a value</span></span><br><span class="line">look_ahead i1 (carry, a, b); <span class="comment">// module instance drives carry</span></span><br><span class="line">overflow_check i2 (carry, a, b); <span class="comment">// ERROR! 2nd driver of carry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> look_ahead (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> carry,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] a, b);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> overflow_check (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> carry,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] a, b);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：Use  variables  for  single-driver  logic,  and  use  nets  for  multi-driver logic.</p>
<h3 id="Signed-and-unsigned-modifiers"><a href="#Signed-and-unsigned-modifiers" class="headerlink" title="Signed and unsigned modifiers"></a>Signed and unsigned modifiers</h3><p>verilog 2001 中添加了有符号数的用法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]	u;			<span class="comment">// unsigned 8-bit variable</span></span><br><span class="line"><span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] data;	<span class="comment">// signed 8-bit variable</span></span><br></pre></td></tr></table></figure>



<p>在systemverilog 中添加了新的有符号数： byte, shortint, int, and longint。并且sv 提供了无符号数的声明：unsigned。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用unsigned 将有符号数变成无符号数</span></span><br><span class="line"><span class="keyword">int</span> s_int; <span class="comment">// signed 32-bit variable</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">unsigned</span> u_int; <span class="comment">// unsigned 32-bit variable</span></span><br></pre></td></tr></table></figure>



<h3 id="3-9-数据类型转换"><a href="#3-9-数据类型转换" class="headerlink" title="3.9 数据类型转换"></a>3.9 数据类型转换</h3><p><strong>使用编译时强制转换运算符进行综合。</strong></p>
<h4 id="静态编译时强制转换"><a href="#静态编译时强制转换" class="headerlink" title="静态编译时强制转换"></a>静态编译时强制转换</h4><p><strong>usag</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、type casting</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">type</span>&gt;‘(&lt;expression&gt;)  <span class="comment">//将值转换为任何类型，包括用户定义的类型。例如</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>+ <span class="keyword">int</span>’(<span class="number">2</span><span class="variable">.0</span> * <span class="number">3</span><span class="variable">.0</span>); <span class="comment">// cast result of </span></span><br><span class="line">					<span class="comment">// (2.0 * 3.0) to int,</span></span><br><span class="line">					<span class="comment">// then add to 7 </span></span><br><span class="line"><span class="comment">//2、size casting</span></span><br><span class="line">&lt;size&gt;’(&lt;expression&gt;) <span class="comment">//— casts a value to any vector size. For example:</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] a, b, y;</span><br><span class="line">	y = a + b**<span class="number">16</span>&#x27;(<span class="number">2</span>); <span class="comment">// cast literal value 2  to be 16 bits wide</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、sign casting</span></span><br><span class="line">&lt;sign&gt;’(&lt;expression&gt;) <span class="comment">//— casts a value to signed or unsigned. For example:</span></span><br><span class="line"><span class="keyword">shortint</span> a, b;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = y - <span class="keyword">signed</span>&#x27;(&#123;a,b&#125;); <span class="comment">// cast concatenation // result to a signed value</span></span><br></pre></td></tr></table></figure>



<h4 id="综合指南-1"><a href="#综合指南-1" class="headerlink" title="综合指南"></a>综合指南</h4><p>静态的编译时强制转换运算符是可综合的。综合编译器可能不支持动态 $cast 系统函数。</p>
<h3 id="3-10-常量"><a href="#3-10-常量" class="headerlink" title="3.10 常量"></a>3.10 常量</h3><p>在seystem Verilog 中添加了一个关键字<strong>const</strong> 常量类型。</p>
<p>const 常量的声明必须包含一个type。</p>
<p><strong>常量的声明：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] C1 = <span class="number">7</span>; 	<span class="comment">// 24-bit constant</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C2 = <span class="number">15</span>; 			<span class="comment">// 32-bit constant</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">real</span> C3 = <span class="number">3</span><span class="variable">.14</span>; 		<span class="comment">// real constant</span></span><br><span class="line"><span class="keyword">const</span> C4 = <span class="number">5</span>; 				<span class="comment">// ERROR, no type</span></span><br></pre></td></tr></table></figure>



<p><strong>const 可用于自动任务和函数</strong></p>
<p>const 常量本质上是一个只能被初始化的变量。因为常量的 const 形式在运行时而不是细化时接收它的值，所以 const 常量可以在自动任务或函数中声明，也可以在模块或静态任务和函数中声明。在 begin…end 或 fork…join 块中声明的变量也可以声明为 const 常量。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> <span class="keyword">automatic</span> C;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>; <span class="comment">// N is a constant</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>



<h2 id="第四章-User-Defined-and-Enumerated-Types"><a href="#第四章-User-Defined-and-Enumerated-Types" class="headerlink" title="第四章 User-Defined and Enumerated Types"></a>第四章 User-Defined and Enumerated Types</h2><h3 id="4-1-User-defined-types"><a href="#4-1-User-defined-types" class="headerlink" title="4.1 User-defined types"></a>4.1 User-defined types</h3><p>typedef defines a user-defined type</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> unit;</span><br><span class="line">……</span><br><span class="line">unit a,b;	<span class="comment">//two variable of type unit</span></span><br></pre></td></tr></table></figure>

<p>用户定义的类型可以在本地、包中或外部在编译单元范围内定义。</p>
<h4 id="Local-typedef-definitions"><a href="#Local-typedef-definitions" class="headerlink" title="Local typedef definitions"></a>Local typedef definitions</h4><p>using typedef locally</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> alu (...);</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] nibble;</span><br><span class="line">    nibble opA, opB; 	<span class="comment">// variables of the</span></span><br><span class="line">    					<span class="comment">// nibble type</span></span><br><span class="line">    nibble [<span class="number">7</span>:<span class="number">0</span>] data; 	<span class="comment">// a 32-bit vector made</span></span><br><span class="line">    					<span class="comment">// from 8 nibble types</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="Shared-typedef-definitions"><a href="#Shared-typedef-definitions" class="headerlink" title="Shared typedef definitions"></a>Shared typedef definitions</h4><p>当一个用户定义类型被很多不同的模块使用时，typedef 定义可以在包中声明。</p>
<h5 id="typedef-definitions-in-packages"><a href="#typedef-definitions-in-packages" class="headerlink" title="typedef definitions in packages"></a>typedef definitions in packages</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">	<span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcodes_t opcode;</span><br><span class="line">    &#125; instruction_t;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a, b);</span><br><span class="line">    	<span class="comment">// code for a custom 32-bit multiplier goes here</span></span><br><span class="line">    	<span class="keyword">return</span> a * b; <span class="comment">// abstract multiplier (no error detection)</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>

<p><strong>example2</strong></p>
<p>Directly referencing typedef definitions from a package </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chip_types; </span><br><span class="line">	<span class="meta">`<span class="meta-keyword">ifdef</span> TWO_STATE</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">bit</span> dtype_t;</span><br><span class="line">    <span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">logic</span> dtype_t;</span><br><span class="line">    <span class="meta">`<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> counter</span><br><span class="line">(<span class="keyword">output</span> chip_types::dtype_t [<span class="number">15</span>:<span class="number">0</span>] count,</span><br><span class="line"><span class="keyword">input</span> chip_types::dtype_t clock, resetN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">		<span class="keyword">if</span> (!resetN) count &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> count &lt;= count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>





<h5 id="typedef-definitions-in-unit"><a href="#typedef-definitions-in-unit" class="headerlink" title="typedef definitions in  $unit"></a>typedef definitions in  $unit</h5><p>typedef 定义也可以在外部声明，在编译单元范围内。</p>
<p>**注意:**外部编译单元范围声明不是全局的</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* External declarations *******************/</span></span><br><span class="line"><span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.2a&quot;</span>; <span class="comment">// external constant</span></span><br><span class="line"><span class="keyword">reg</span> resetN = <span class="number">1</span>; <span class="comment">// external variable (active low)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="comment">// external user-defined type</span></span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">        <span class="keyword">reg</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    &#125; instruction_word_t;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> log2 (<span class="keyword">input</span> <span class="keyword">int</span> n); <span class="comment">// external function</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">    log2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        n = n/<span class="number">2</span>;</span><br><span class="line">        log2++;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>(log2);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">/********************* module definition *********************/</span></span><br><span class="line"><span class="comment">// external declaration is used to define port types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> register (<span class="keyword">output</span> instruction_word_t q,</span><br><span class="line">				<span class="keyword">input</span> instruction_word_t d,</span><br><span class="line">				<span class="keyword">input</span> <span class="keyword">wire</span> clock );</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    <span class="keyword">if</span> (!resetN) q &lt;= <span class="number">0</span>; <span class="comment">// use external reset</span></span><br><span class="line">    <span class="keyword">else</span> q &lt;= d;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>example2：</strong></p>
<p>Importing package typedef definitions into $unit</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chip_types; </span><br><span class="line">	<span class="meta">`<span class="meta-keyword">ifdef</span> TWO_STATE</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">bit</span> dtype_t;</span><br><span class="line">    <span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">logic</span> dtype_t;</span><br><span class="line">    <span class="meta">`<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chip_types::dtype_t; <span class="comment">// import definition into $unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> counter</span><br><span class="line">(<span class="keyword">output</span> dtype_t [<span class="number">15</span>:<span class="number">0</span>] count,</span><br><span class="line"> <span class="keyword">input</span>  dtype_t clock, resetN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">		<span class="keyword">if</span> (!resetN) count &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> count &lt;= count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 如果package 中含有多个typedefs,可以使用通配符导入：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chip_types::*; <span class="comment">// wildcard import</span></span><br></pre></td></tr></table></figure>



<h4 id="user-defined-types-命名惯例"><a href="#user-defined-types-命名惯例" class="headerlink" title="user-defined types 命名惯例"></a>user-defined types 命名惯例</h4><p>为了使源代码更易于阅读和维护，一个常见的命名约定是以字符“_t”结束所有typedef的type。</p>
<h3 id="Enumerated-types-枚举类型"><a href="#Enumerated-types-枚举类型" class="headerlink" title="Enumerated types 枚举类型"></a>Enumerated types 枚举类型</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vari-able RGB can have the values of red, green and blue:</span></span><br><span class="line"><span class="keyword">enum</span> &#123;red,green,blue&#125; RGB;</span><br></pre></td></tr></table></figure>



<p>example</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chip_types;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;FETCH, WRITE, ADD, SUB,</span><br><span class="line">				  MULT, DIV, SHIFT, NOP &#125; instr_t;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chip_types::*; <span class="comment">// import package definitions into $unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> controller (	<span class="keyword">output</span> <span class="keyword">logic</span> read, write,</span><br><span class="line">					<span class="keyword">input</span> instr_t instruction,</span><br><span class="line">					<span class="keyword">input</span> <span class="keyword">wire</span> clock, resetN);</span><br><span class="line">	<span class="keyword">enum</span> &#123;WAITE, LOAD, STORE&#125; State, NextState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    	<span class="keyword">if</span> (!resetN) State &lt;= WAITE;</span><br><span class="line">    	<span class="keyword">else</span> State &lt;= NextState;</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (State)</span><br><span class="line">            WAITE: NextState = LOAD;</span><br><span class="line">            LOAD: NextState = STORE;</span><br><span class="line">            STORE: NextState = WAITE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    	read = <span class="number">0</span>; write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (State == LOAD &amp;&amp; instruction == FETCH)</span><br><span class="line">    	read = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (State == STORE &amp;&amp; instruction == WRITE)</span><br><span class="line">    	write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Importing-enumerated-types-from-packages"><a href="#Importing-enumerated-types-from-packages" class="headerlink" title="Importing enumerated types from packages"></a>Importing enumerated types from packages</h4><p><strong>注意：</strong> 导入一个枚举类型定义的名字并不会自动导入枚举标签值。</p>
<p>example: 下面的这个例子并不工作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chip_types;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;WAITE, LOAD, READY&#125; states_t;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> chip (...);</span><br><span class="line">    <span class="keyword">import</span> chip_types::states_t; 	<span class="comment">// imports the</span></span><br><span class="line">                                    <span class="comment">// typedef name,</span></span><br><span class="line">                                    <span class="comment">// only</span></span><br><span class="line">    states_t state, next_state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">negedge</span> resetN)</span><br><span class="line">        <span class="keyword">if</span> (!resetN)</span><br><span class="line">        	state &lt;= WAITE; <span class="comment">// ERROR: &quot;WAITE&quot; has not been imported!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	state &lt;= next_state;</span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>为了使枚举类型标签可见，有两种方法可以实现：</p>
<ol>
<li>必须显示的导入每一个标签；</li>
<li>或者这个包使用通配符导入：使用通配符导入可以确保枚举type name 与enumerated value lables 在导入的作用范围内是可见的。</li>
</ol>
<p>example：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chip_types::*; <span class="comment">// wildcard import</span></span><br></pre></td></tr></table></figure>

<h4 id="Enumerated-type-label-sequences"><a href="#Enumerated-type-label-sequences" class="headerlink" title="Enumerated type label sequences"></a>Enumerated type label sequences</h4><p>The  following  example  creates  an  enumerated  list  with  the  labels RESET, S0 through S4, and W6 through W9:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;RESET, S[<span class="number">5</span>], W[<span class="number">6</span>:<span class="number">9</span>]&#125; state;</span><br></pre></td></tr></table></figure>

<h4 id="enumerated-labels-must-be-unique"><a href="#enumerated-labels-must-be-unique" class="headerlink" title="enumerated labels must be unique"></a>enumerated labels must be unique</h4><p>枚举类型列表中的标签在该范围内必须是唯一的。可以包含枚举类型声明的范围是编译单元、模块、接口、程序、begin…end 块、fork…join 块、任务和函数</p>
<p><strong>example</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FSM (...);</span><br><span class="line">	<span class="keyword">enum</span> &#123;GO, STOP&#125; fsm1_state;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">enum</span> &#123;WAITE, GO, DONE&#125; fsm2_state; <span class="comment">// ERROR GO</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改上面的错误:可以使用在两个begin end 中声明</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FSM (...);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">begin</span>: fsm1</span><br><span class="line">        <span class="keyword">enum</span> &#123;STOP, GO&#125; fsm1_state;</span><br><span class="line">    	...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">begin</span>: fsm2</span><br><span class="line">    	<span class="keyword">enum</span> &#123;WAITE, GO, DONE&#125; fsm2_state;</span><br><span class="line">    	...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="Enumerated-type-values"><a href="#Enumerated-type-values" class="headerlink" title="Enumerated type values"></a>Enumerated type values</h4><p>默认的：枚举中的标签实际是一个int type的值,枚举体中的标签值从0依次递增：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">enum</span> &#123;a,b,c,d&#125; state; <span class="comment">//a-d 依次表示0-3</span></span><br></pre></td></tr></table></figure>

<p>users can specify the label’s value</p>
<p>枚举体中的标签的值可以被用户指定：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;ONE	= <span class="number">1</span>,</span><br><span class="line">      FIVE  = <span class="number">5</span>,</span><br><span class="line">      TEN   = <span class="number">10</span>&#125; dtate;</span><br></pre></td></tr></table></figure>

<p>example2</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;A=<span class="number">1</span>, B, C, X=<span class="number">24</span>, Y, Z&#125; list1;<span class="comment">//A=1,B=2,C=3,X=24,Y=25,Z=26</span></span><br></pre></td></tr></table></figure>

<p>枚举体中标签的值只能是唯一的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;A=<span class="number">1</span>, B, C, D=<span class="number">3</span>&#125; list2; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<h4 id="基于type-的枚举体类型"><a href="#基于type-的枚举体类型" class="headerlink" title="基于type 的枚举体类型"></a>基于type 的枚举体类型</h4><p>枚举体默认是基于int(32bit 2-state)类型的。</p>
<p>system verilog 允许显式的指明枚举体基于的类去声明。</p>
<p>for example </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enumerated type with a 1-bit wide,</span></span><br><span class="line"><span class="comment">// 2-state base type</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">bit</span> &#123;TRUE, FALSE&#125; Boolean; </span><br><span class="line"></span><br><span class="line"><span class="comment">// enumerated type with a 2-bit wide,</span></span><br><span class="line"><span class="comment">// 4-state base type</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;WAITE, LOAD, READY&#125; state;</span><br></pre></td></tr></table></figure>

<p>如果为显式类型枚举类型的枚举标签赋值，则其大小必须与基本类型的大小匹配。</p>
<p>for example </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;WAITE = <span class="number">3</span>’b001,</span><br><span class="line">                  LOAD 	= <span class="number">3</span>’b010,</span><br><span class="line">                  READY = <span class="number">3</span>’b100&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum variable defaults to an int base type. An error will result from assigning a 3-bit value to the labels.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;WAITE = <span class="number">3</span>’b001, <span class="comment">// ERROR! </span></span><br><span class="line">	  LOAD 	= <span class="number">3</span>’b010,</span><br><span class="line">      READY = <span class="number">3</span>’b100&#125; state;</span><br><span class="line"><span class="comment">//枚举列表中的标签多于基本类型大小可以表示的标签也是错误的。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> &#123;A=<span class="number">1</span>’b0, B, C&#125; list5; <span class="comment">// ERROR: too many labels for 1-bit size</span></span><br></pre></td></tr></table></figure>

<p>如果枚举值的基类型是 4 状态类型，则将 X 或 Z 的值分配给枚举标签是合法的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> &#123;ON=<span class="number">1</span>’b1, OFF=<span class="number">1</span>’bz&#125; out; <span class="comment">//正确的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">&#123;WAITE, ERR=<span class="number">2</span>’bxx, LOAD, READY&#125; state;	<span class="comment">//如果有一个标签被分配成了X或者Z,那么后面的标签的值需要明确指定。</span></span><br><span class="line"><span class="comment">// ERROR: cannot determine a value for LOAD</span></span><br></pre></td></tr></table></figure>

<h4 id="枚举类型可以声明为typedef"><a href="#枚举类型可以声明为typedef" class="headerlink" title="枚举类型可以声明为typedef"></a>枚举类型可以声明为typedef</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;WAITE, LOAD, READY&#125; states_t;</span><br><span class="line">states_t state, next_state;</span><br></pre></td></tr></table></figure>



<h4 id="枚举类型的操作"><a href="#枚举类型的操作" class="headerlink" title="枚举类型的操作"></a>枚举类型的操作</h4><p>枚举类型是半强类型的。只能分配枚举类型：</p>
<ul>
<li>A label from its enumerated type list</li>
<li>Another enumerated type of the same type (that is, declared with the same typedef definition) </li>
<li>A value cast to the typedef type of the enumerated type</li>
</ul>
<p>当对枚举类型值执行操作时，枚举值会自动转换为表示枚举类型列表中标签的基本类型和内部值。如果未显式声明枚举类型的基类型，则基类型和标签将默认为 int 类型。</p>
<p>In the following example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;WAITE, LOAD, READY&#125; states_t;</span><br><span class="line">states_t state, next_state;</span><br><span class="line"><span class="keyword">int</span> foo;</span><br></pre></td></tr></table></figure>

<p>WAITE will be represented as an int with a value of 0, LOAD as an int with a value of 1, and READY as an int value of 2.<br>以下对枚举类型的赋值操作是合法的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = next_state; <span class="comment">// legal operation</span></span><br></pre></td></tr></table></figure>

<p>The <strong>state</strong> and <strong>next_state</strong> are both enumerated type variables of the  same  <strong>type</strong>  (<strong>states_t</strong>).  A  value  in  one  enumerated  type  vari-able  can  be  assigned  to  another  enumerated  <strong>type</strong>  variable  of  the<br>same type.<br>The assignment statement below is also legal. The enumerated type of state is represented as a base type of <strong>int</strong>, which is added to the literal integer 1. The result of the operation is an <strong>int</strong> value, which is assigned to a variable of type <strong>int</strong>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = state + <span class="number">1</span>; <span class="comment">// legal operation</span></span><br></pre></td></tr></table></figure>

<p>The  converse  of  the  preceding  example  is  illegal.  An  error  will result if a value that is not of the same enumerated type is assigned to an enumerated type variable. For example: </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = foo + <span class="number">1</span>; <span class="comment">// ERROR: illegal assignment</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，foo + 1 的结果类型是一个 int，它与 state 不同，state 是一个 states_t 类型。</p>
<p>下面的例子也是非法的，并且会导致错误：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state = state + <span class="number">1</span>; 		<span class="comment">// illegal operation</span></span><br><span class="line">state++; 				<span class="comment">// illegal operation</span></span><br><span class="line">next_state += state; 	<span class="comment">// illegal operation</span></span><br></pre></td></tr></table></figure>

<p>The enumerated type of <strong>state</strong> is represented as a base type of <strong>int</strong>, which is added to the literal integer 1. The result of the operation is an <strong>int</strong>  value.  It  is  an  error  to  directly  assign  this  <strong>int</strong>  result  to  a variable of the enumerated type <strong>state</strong>, which is a <strong>states_t</strong> type. </p>
<h4 id="将表达式转换为枚举类型"><a href="#将表达式转换为枚举类型" class="headerlink" title="将表达式转换为枚举类型"></a>将表达式转换为枚举类型</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;WAITE, LOAD, READY&#125; states_t;</span><br><span class="line">states_t state, next_state;</span><br><span class="line">next_state = states_t’(state++); <span class="comment">// legal</span></span><br><span class="line"><span class="built_in">$cast</span>(next_state, state + <span class="number">1</span>); <span class="comment">// legal</span></span><br></pre></td></tr></table></figure>



<p>注意：转换运算符可能会导致超出范围。转换运算符将始终执行转换操作和赋值。没有检查要分配的值是否在枚举类型集的合法范围内。使用前面关于 state 和 next_state 的枚举类型示例，如果 state 的值为 READY，表示为值 2，则将其递增 1 将导致整数值 3。将此值分配给 next_state 超出了next_state 的枚举类型列表中的值范围。</p>
<p>动态的转换$cast(next_state, state + 1); // legal 可能会无法综合。</p>
<p>SystemVerilog 提供了几个内置函数（称为方法）来遍历枚举类型列表中的值。这些方法会自动处理枚举类型的半强类型特性，从而可以轻松地执行诸如递增到枚举类型列表中的下一个值、跳转到列表开头或跳转到列表末尾等操作。 使用这些方法，不必知道枚举列表中的标签或值。</p>
<p>这些处理枚举列表的特殊方法以类似于 C++ 类方法的方式调用。也就是说，方法的名称附加在枚举类型名称的末尾，并以句点作为分隔符。</p>
<p><enum_variable_name>.first — 返回指定变量枚举列表中第一个成员的值。</enum_variable_name></p>
<p> <enum_variable_name>.last — 返回枚举列表中最后一个成员的值。</enum_variable_name></p>
<p><enum_variable_name>.next(<N>)</N></enum_variable_name></p>
<p><enum_variable_name>.prev(<N>)</N></enum_variable_name></p>
<p><enum_variable_name>.num — 返回给定变量的枚举列表中的标签数。</enum_variable_name></p>
<p><enum_variable_name>.name — 返回给定枚举类型中值的标签的字符串表示形式。如果该值不是枚举的成员，则 name 方法返回一个空字符串。枚举类型方法使用 C++ 语法</enum_variable_name></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Example  <span class="number">4</span>-<span class="number">5</span>  illustrates  a  state  machine  model  that  sequences through  its  states,  using  some  of  the  enumeration  methods  listed above. The example is a simple <span class="number">0</span> to <span class="number">15</span> confidence counter, where:</span><br><span class="line">• The  in_sync  <span class="keyword">output</span>  is  initially  <span class="number">0</span>;  it  is  set  when  the  counter reaches <span class="number">8</span>; in_sync is cleared again <span class="keyword">if</span> the counter goes to <span class="number">0</span>.</span><br><span class="line">• If  the  compare  <span class="keyword">and</span>  synced  <span class="keyword">input</span>  flags  are  both  false,  the counter stays at its current count.</span><br><span class="line">• If  the  compare  flag  <span class="keyword">and</span>  the  synced  flag  are  both  true,  the counter increments by <span class="number">1</span> (but cannot go beyond <span class="number">15</span>).</span><br><span class="line">• If  the  compare  flag  is  true  but  the  synced  flag  is  false,  the counter decrements by <span class="number">2</span> (but cannot go below <span class="number">0</span>).</span><br><span class="line"><span class="comment">//Using special methods to iterate through enumerated type lists</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> confidence_counter(<span class="keyword">input</span> <span class="keyword">logic</span> synced, compare, 	resetN, clock,</span><br><span class="line">						  <span class="keyword">output</span> <span class="keyword">logic</span> in_sync);</span><br><span class="line">	<span class="keyword">enum</span> &#123;cnt[<span class="number">0</span>:<span class="number">15</span>]&#125; State, Next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">     	<span class="keyword">if</span> (!resetN) State &lt;= cnt0;</span><br><span class="line">    	<span class="keyword">else</span> State &lt;= Next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    	Next = State; <span class="comment">// default NextState value</span></span><br><span class="line">        <span class="keyword">case</span> (State)</span><br><span class="line">            cnt0 : <span class="keyword">if</span> (compare &amp;&amp; synced) Next = State<span class="variable">.next</span>;</span><br><span class="line">            cnt1 : <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (compare &amp;&amp; synced) Next = State<span class="variable">.next</span>;</span><br><span class="line">                <span class="keyword">if</span> (compare &amp;&amp; !synced) Next = State<span class="variable">.first</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            cnt15: <span class="keyword">if</span> (compare &amp;&amp; !synced) Next = State<span class="variable">.prev</span>(<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (compare &amp;&amp; synced) Next = State<span class="variable">.next</span>;</span><br><span class="line">                <span class="keyword">if</span> (compare &amp;&amp; !synced) Next = State<span class="variable">.prev</span>(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">        <span class="keyword">if</span> (!resetN) in_sync &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (State == cnt8) in_sync &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (State == cnt0) in_sync &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="打印枚举类型"><a href="#打印枚举类型" class="headerlink" title="打印枚举类型"></a>打印枚举类型</h4><p>枚举类型值可以打印为标签的内部值，也可以打印为标签的名称。直接打印枚举类型会打印枚举类型的内部值。使用枚举类型名称方法访问表示当前值的标签<strong>name</strong>。此方法返回一个包含名称的字符串。然后可以将此字符串传递给 $display 以进行打印。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FSM (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN,</span><br><span class="line">    		<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] control);</span><br><span class="line">    		<span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;WAITE=<span class="number">3&#x27;b001</span>,</span><br><span class="line">    LOAD =<span class="number">3&#x27;b010</span>,</span><br><span class="line">    READY=<span class="number">3&#x27;b010</span>&#125; State, Next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">        <span class="keyword">if</span> (!resetN) State &lt;= WAITE;</span><br><span class="line">        <span class="keyword">else</span> State &lt;= Next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    	<span class="built_in">$display</span>(<span class="string">&quot;\nCurrent state is %s (%b)&quot;</span>, State<span class="variable">.name</span>, State);</span><br><span class="line">    	<span class="keyword">case</span> (State)</span><br><span class="line">            WAITE: Next = LOAD;</span><br><span class="line">            LOAD: Next = READY;</span><br><span class="line">            READY: Next = WAITE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    	<span class="built_in">$display</span>(<span class="string">&quot;Next state will be %s (%b)&quot;</span>, Next<span class="variable">.name</span>, Next);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> control = State;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第五章-SystemVerilog-Arrays-Structures-and-Unions"><a href="#第五章-SystemVerilog-Arrays-Structures-and-Unions" class="headerlink" title="第五章 SystemVerilog Arrays,Structures and Unions"></a>第五章 SystemVerilog Arrays,Structures and Unions</h2><h3 id="5-1-Structures-结构体"><a href="#5-1-Structures-结构体" class="headerlink" title="5.1 Structures 结构体"></a>5.1 Structures 结构体</h3><p><strong>定义：</strong> 结构体使用<strong>struct</strong>关键字来定义，结构体的成员可以是任意变量类型，包括typpedef 用户自定义类型，和任何的常量类型。for example：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; 				<span class="comment">// 32-bit variables</span></span><br><span class="line">    opcode_t opcode; 		<span class="comment">// user-defined type</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address; 	<span class="comment">// 24-bit variable</span></span><br><span class="line">    <span class="keyword">bit</span> error; 				<span class="comment">// 1-bit 2-state var.</span></span><br><span class="line">&#125; Instruction_Word;</span><br></pre></td></tr></table></figure>

<p>访问结构体成员的方法与C类似：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;structure_name&gt;.&lt;variable_name&gt;</span><br></pre></td></tr></table></figure>

<p>给结构体成员赋值：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instruction_Word<span class="variable">.address</span> = <span class="number">32</span>’hF000001E;</span><br></pre></td></tr></table></figure>



<h4 id="Structure-declartions"><a href="#Structure-declartions" class="headerlink" title="Structure declartions"></a>Structure declartions</h4><p>结构体可以是变量或者nets：</p>
<p>如果不使用var,或者nets类型的声明，隐式为var型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结构体整体声明成一个变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">struct</span> &#123; <span class="comment">// structure variable</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; Instruction_Word_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将结构体整体声明成一个线网</span></span><br><span class="line"><span class="keyword">wire</span> <span class="keyword">struct</span> &#123; <span class="comment">// structure net</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; Instruction_Word_net;</span><br></pre></td></tr></table></figure>

<h4 id="structures-can-be-user-defined-types"><a href="#structures-can-be-user-defined-types" class="headerlink" title="structures can be user-defined types"></a>structures can be user-defined types</h4><p>用户定义的结构体类型是不占用存储空间的。在对用户定义的结构体类型变量进行赋值之前，需要首先进行声明。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="comment">// structure definition</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction_word_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line">instruction_word_t IW; <span class="comment">// structure allocation</span></span><br></pre></td></tr></table></figure>

<p>当一个结构被声明而不使用 typedef 时，它被称为匿名结构。</p>
<p>for example：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction;</span><br></pre></td></tr></table></figure>

<h4 id="共享结构体的定义：-using-packages-or-unit"><a href="#共享结构体的定义：-using-packages-or-unit" class="headerlink" title="共享结构体的定义： using packages or $unit"></a>共享结构体的定义： using packages or $unit</h4><p>结构类型可以在模块或接口中定义，允许在整个设计块中使用。如果一个结构类型定义需要在多个设计块中使用，或者作为模块或接口的一个端口，那么结构定义应该放在一个包中，并导入到设计块或$unit 编译单元空间.结构体类型也可以直接在$unit 编译单元空间中定义。</p>
<p>example1：package</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">	<span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcodes_t opcode;</span><br><span class="line">    &#125; instruction_t;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a, b);</span><br><span class="line">    	<span class="comment">// code for a custom 32-bit multiplier goes here</span></span><br><span class="line">    	<span class="keyword">return</span> a * b; <span class="comment">// abstract multiplier (no error detection)</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>

<p>example2：  $unit</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* External declarations *******************/</span></span><br><span class="line"><span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.2a&quot;</span>; <span class="comment">// external constant</span></span><br><span class="line"><span class="keyword">reg</span> resetN = <span class="number">1</span>; <span class="comment">// external variable (active low)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="comment">// external user-defined type</span></span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">        <span class="keyword">reg</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    &#125; instruction_word_t;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> log2 (<span class="keyword">input</span> <span class="keyword">int</span> n); <span class="comment">// external function</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">    log2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        n = n/<span class="number">2</span>;</span><br><span class="line">        log2++;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>(log2);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">/********************* module definition *********************/</span></span><br><span class="line"><span class="comment">// external declaration is used to define port types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> register (<span class="keyword">output</span> instruction_word_t q,</span><br><span class="line">				<span class="keyword">input</span> instruction_word_t d,</span><br><span class="line">				<span class="keyword">input</span> <span class="keyword">wire</span> clock );</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    <span class="keyword">if</span> (!resetN) q &lt;= <span class="number">0</span>; <span class="comment">// use external reset</span></span><br><span class="line">    <span class="keyword">else</span> q &lt;= d;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值"></a>结构体赋值</h4><h5 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">	<span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">	<span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction_word_t;</span><br><span class="line"></span><br><span class="line">instruction_word_t IW = ’&#123;<span class="number">100</span>, <span class="number">3</span>, <span class="number">8</span>’hFF, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="结构体成员赋值"><a href="#结构体成员赋值" class="headerlink" title="结构体成员赋值"></a>结构体成员赋值</h5><p>三种方法实现结构体的赋值：</p>
<p>方法一：结构体成员赋值</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instr_t;</span><br><span class="line"></span><br><span class="line">instr_t IW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">	<span class="keyword">if</span> (!resetN) <span class="keyword">begin</span></span><br><span class="line">        IW<span class="variable">.a</span> = <span class="number">100</span>; <span class="comment">// reference structure member</span></span><br><span class="line">        IW<span class="variable">.b</span> = <span class="number">5</span>;</span><br><span class="line">        IW<span class="variable">.opcode</span> = <span class="number">8</span>’hFF;</span><br><span class="line">        IW<span class="variable">.address</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">    	...</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>方法二：将结构表达式分配给结构体</p>
<p>example1:</p>
<p>a structure expression is enclosed within ’{ … }</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">	<span class="keyword">if</span> (!resetN) IW = ’&#123;<span class="number">100</span>, <span class="number">5</span>, <span class="number">8</span>’hFF, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>example2：</p>
<p>a structure expression  can be listed by order or by member name</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IW = ’&#123;address:<span class="number">0</span>, opcode:<span class="number">8</span>’hFF, a:<span class="number">100</span>, b:<span class="number">5</span>&#125;; <span class="comment">//legal</span></span><br><span class="line"><span class="comment">//It is illegal to mix listing by name and listing by order in the same structure expression.</span></span><br><span class="line">IW = ’&#123;address:<span class="number">0</span>, <span class="number">8</span>’hFF, <span class="number">100</span>, <span class="number">5</span>&#125;; <span class="comment">// ERROR </span></span><br></pre></td></tr></table></figure>

<p>方法三：Default values in structure expressions</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IW = ’&#123;<span class="keyword">default</span>:<span class="number">0</span>&#125;; <span class="comment">// set all members of IW to 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">real</span> r0, r1;</span><br><span class="line">    <span class="keyword">int</span> i0, i1;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction_word_t;</span><br><span class="line">    instruction_word_t IW;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    <span class="keyword">if</span> (!resetN)</span><br><span class="line">    	IW = ’&#123; <span class="keyword">real</span>:<span class="number">1</span><span class="variable">.0</span>, <span class="keyword">default</span>:<span class="number">0</span> &#125;;</span><br><span class="line">    	<span class="comment">// assign all real members a default of 1.0</span></span><br><span class="line">    	<span class="comment">// and all other members a default of 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    	...</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>default value precedence</p>
<p>结构成员如何赋值是有优先顺序的。 default 关键字的优先级最低，将被任何特定于类型的默认值覆盖。特定类型的默认值将被任何显式命名的成员值覆盖。下面的结构表达式将为 r0 赋值 1.0，为 r1 赋值 3.1415，并将结构的所有其他成员赋值为 0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">real</span> r0, r1;</span><br><span class="line">    <span class="keyword">int</span> i0, i1;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction_word_t;</span><br><span class="line"></span><br><span class="line">instruction_word_t IW;</span><br><span class="line"></span><br><span class="line">	IW = ’&#123; <span class="keyword">real</span>:<span class="number">1</span><span class="variable">.0</span>, <span class="keyword">default</span>:<span class="number">0</span>, r1:<span class="number">3</span><span class="variable">.1415</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="打包和解包结构"><a href="#打包和解包结构" class="headerlink" title="打包和解包结构"></a>打包和解包结构</h4><blockquote>
<p>unpacked structures can have padding</p>
</blockquote>
<p>默认情况下，结构体是解包的。这意味着结构体的成员被视为独立变量或常量，它们以共同的名称组合在一起。 SystemVerilog 未指定软件工具应如何存储解压缩结构体的成员。存储的布局可能因一种软件工具而异。</p>
<blockquote>
<p>packed structures are stored without padding</p>
</blockquote>
<p>可以使用 packed 关键字将结构体显式声明为打包结构体。压缩结构体以指定的顺序将结构体的所有成员存储为连续位。压缩结构存体储为向量，结构体的第一个成员是向量的最左侧字段。结构体中最后一个成员的最右边位是向量的最低有效位，编号为第 0 位。如图 5-1 所示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word;</span><br></pre></td></tr></table></figure>

<p>Figure 5-1: Packed structures are stored as a vector</p>
<table>
<thead>
<tr>
<th align="right">valid</th>
<th align="right">tag</th>
<th align="right">data</th>
</tr>
</thead>
<tbody><tr>
<td align="right">40-39</td>
<td align="right">31</td>
<td align="right">15        0</td>
</tr>
</tbody></table>
<p>压缩结构的成员可以通过成员的名称或使用结构表示的向量的部分选择来引用。以下两个赋值都将赋值给 data_word 结构体的tag成员：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_word<span class="variable">.tag</span>    = <span class="number">8</span>’hf0;</span><br><span class="line">data_word[<span class="number">39</span>:<span class="number">32</span>] = <span class="number">8</span>’hf0; <span class="comment">// same bits as tag</span></span><br></pre></td></tr></table></figure>

<p><strong>Packed structures can only contain integral values</strong></p>
<blockquote>
<p>packed structures must contain packed variables</p>
</blockquote>
<p>压缩结构的所有成员必须是整数值。整数值是可以表示为向量的值，例如字节、整数和使用位或逻辑类型创建的向量。如果结构的任何成员不能表示为向量，则该结构不能被打包。这意味着压缩结构不能包含<strong>real</strong>或<strong>shortreal</strong>变量、unpacked结构体、unpacked联合体或unpacked数组。</p>
<h5 id="包装结构的操作"><a href="#包装结构的操作" class="headerlink" title="包装结构的操作"></a>包装结构的操作</h5><blockquote>
<p>packed structures are seen as vectors</p>
</blockquote>
<p>因为打包结构存储为向量，所以对完整结构的操作被视为向量操作。因此，可以对向量执行的数学运算、逻辑运算和任何其他运算也可以在压缩结构上执行。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word_t;</span><br><span class="line"></span><br><span class="line">data_word_t packet_in, packet_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">	packet_out &lt;= packet_in &lt;&lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h5 id="signed-packed-结构体"><a href="#signed-packed-结构体" class="headerlink" title="signed packed 结构体"></a>signed packed 结构体</h5><blockquote>
<p>a packed structures used as a vector can be signed or unsigned</p>
</blockquote>
<p>压缩结构体可以用有<strong>signed</strong>或<strong>unsigned</strong>关键字声明。当在数学或关系运算中用作向量时，这些修饰符会影响整个结构的感知方式。它们不影响结构成员的感知方式。根据该成员的类型声明，结构的每个成员都被视为有符号或无符号。压缩结构的部分选择始终是无符号的，与 Verilog 中向量的部分选择相同。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> <span class="keyword">signed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word_t;</span><br><span class="line"></span><br><span class="line">	data_word_t A, B;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">		<span class="keyword">if</span> ( A &lt; B ) <span class="comment">// signed comparison</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="通过端口传递结构"><a href="#通过端口传递结构" class="headerlink" title="通过端口传递结构"></a>通过端口传递结构</h4><blockquote>
<p>ports can be declared as a structure type</p>
</blockquote>
<p>结构体可以通过模块和接口端口传递。必须首先使用 <strong>typedef</strong> 将结构体定义为用户定义的类型，然后才能将模块或接口端口声明为结构体类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MULT, DIV&#125; opcode_t;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; </span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcode_t opcode;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">logic</span> error;</span><br><span class="line">    &#125; instruction_word_t;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> alu (</span><br><span class="line">    <span class="keyword">input</span> definitions::instruction_word_t IW,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clock</span><br><span class="line">);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>将包含 typedef 定义的包显式命名为模块端口的一部分的另一种样式是将包导入 $unit 编译单元声明空间。也可以直接在 $unit 空间中定义用户定义的类型。第 2 章讨论了导入包和使用 $unit 编译单元空间。</p>
<p>当一个解压的结构体通过模块端口传递时，必须在端口的每一侧连接一个完全相同类型的结构。在两个不同模块中声明的匿名结构，即使它们具有完全相同的名称、成员和成员名称，也不是同一类型的结构体。</p>
<h4 id="将结构作为参数传递给任务和函数"><a href="#将结构作为参数传递给任务和函数" class="headerlink" title="将结构作为参数传递给任务和函数"></a>将结构作为参数传递给任务和函数</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> processor (...);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MULT, DIV&#125; opcode_t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="comment">// typedef is local</span></span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcode_t opcode;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">logic</span> error;</span><br><span class="line">    &#125; instruction_word_t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> alu (<span class="keyword">input</span> instruction_word_t IW);</span><br><span class="line">   	 	...</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>当调用具有解压缩结构作为形式参数的任务或函数时，必须将完全相同类型的结构传递给任务或函数。匿名结构，即使它具有完全相同的成员和成员名称，也不是同一类型的结构。</p>
<h4 id="综合指南-2"><a href="#综合指南-2" class="headerlink" title="综合指南"></a>综合指南</h4><p>解压缩和压缩结构都是<strong>可综合</strong>的。综合支持通过module port 传递结构，以及 in/out  of<br>tasks  and  functions。支持按成员名称和值列表为结构分配值。</p>
<h3 id="5-2Unions-联合体"><a href="#5-2Unions-联合体" class="headerlink" title="5.2Unions 联合体"></a>5.2Unions 联合体</h3><blockquote>
<p>声明：</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>（</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">unsigned</span> u;</span><br><span class="line">） data;</span><br><span class="line">	...</span><br><span class="line">data<span class="variable">.i</span> = -<span class="number">5</span>;</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;data is %d&quot;</span>,data<span class="variable">.i</span>);</span><br><span class="line"></span><br><span class="line">data<span class="variable">.u</span> = -<span class="number">5</span>;</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;now data is %d&quot;</span>,data<span class="variable">.u</span>);</span><br></pre></td></tr></table></figure>

<p><strong>联合体减少存储并可能提高性能</strong></p>
<p>虽然声明语法相似，但联合与结构有很大不同。一个结构可以存储多个值。它是单一名称下的变量集合。一个联合只能存储一个值。联合的典型应用是当一个值可以表示为几种不同的类型，但在任何特定时刻仅作为一种类型。</p>
<p><strong>Typed and anonymous unions</strong></p>
<p>可以使用 typedef 将联合定义为类型，就像结构一样。定义为用户定义类型的联合称为类型化联合。如果不使用 typedef，则联合称为匿名联合。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123; <span class="comment">// typed union </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">unsigned</span> u;</span><br><span class="line">&#125; data_t;</span><br><span class="line"></span><br><span class="line">data_t a, b; <span class="comment">// two variables of type data_t</span></span><br></pre></td></tr></table></figure>

<h4 id="Unpacked-unions"><a href="#Unpacked-unions" class="headerlink" title="Unpacked unions"></a>Unpacked unions</h4><p><strong>Unpacked  unions  are  not  synthesizable.</strong>   对于系统级和传输级是有用的。</p>
<h4 id="Packed-unions"><a href="#Packed-unions" class="headerlink" title="Packed unions"></a>Packed unions</h4><p>packed unions are syntheiszable。</p>
<p>  A  packed  union cannot contain real or shortreal variables, unpacked structures,<br>unpacked unions, or unpacked arrays.</p>
<h4 id="An-example-of-using-structures-and-unions"><a href="#An-example-of-using-structures-and-unions" class="headerlink" title="An example of using structures and unions"></a>An example of using structures and unions</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MULT, DIV, SL, SR&#125; opcode_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNSIGNED, SIGNED&#125; operand_type_t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">union</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] u_data;</span><br><span class="line">        <span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">31</span>:<span class="number">0</span>] s_data;</span><br><span class="line">    &#125; data_t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        opcode_t opc;</span><br><span class="line">        operand_type_t op_type;</span><br><span class="line">        data_t op_a;</span><br><span class="line">        data_t op_b;</span><br><span class="line">    &#125; instr_t;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> definitions::*; <span class="comment">// import package into $unit space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> alu </span><br><span class="line">(<span class="keyword">input</span> instr_t IW,</span><br><span class="line"><span class="keyword">output</span> data_t alu_out);</span><br><span class="line">    <span class="keyword">always</span> @(IW) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (IW<span class="variable">.op_type</span> == SIGNED) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (IW<span class="variable">.opc</span>)</span><br><span class="line">                ADD : alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> + IW<span class="variable">.op_b</span><span class="variable">.s_data</span>;</span><br><span class="line">                SUB : alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> - IW<span class="variable">.op_b</span><span class="variable">.s_data</span>;</span><br><span class="line">                MULT: alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> * IW<span class="variable">.op_b</span><span class="variable">.s_data</span>;</span><br><span class="line">                DIV : alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> / IW<span class="variable">.op_b</span><span class="variable">.s_data</span>;</span><br><span class="line">                SL  : alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> &lt;&lt;&lt; <span class="number">2</span>;</span><br><span class="line">                SR  : alu_out<span class="variable">.s_data</span> = IW<span class="variable">.op_a</span><span class="variable">.s_data</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (IW<span class="variable">.opc</span>)</span><br><span class="line">                ADD : alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> + IW<span class="variable">.op_b</span><span class="variable">.u_data</span>;</span><br><span class="line">                SUB : alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> - IW<span class="variable">.op_b</span><span class="variable">.u_data</span>;</span><br><span class="line">                MULT: alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> * IW<span class="variable">.op_b</span><span class="variable">.u_data</span>;</span><br><span class="line">                DIV : alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> / IW<span class="variable">.op_b</span><span class="variable">.u_data</span>;</span><br><span class="line">                SL  : alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                SR  : alu_out<span class="variable">.u_data</span> = IW<span class="variable">.op_a</span><span class="variable">.u_data</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-Arrays"><a href="#5-3-Arrays" class="headerlink" title="5.3 Arrays"></a>5.3 Arrays</h3><h4 id="unpacked-arrays"><a href="#unpacked-arrays" class="headerlink" title="unpacked arrays"></a>unpacked arrays</h4><p>verilog-1995 标准中：支持数组：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data_type&gt; &lt;vector_size&gt; &lt;array_name&gt; &lt;array_dimensions&gt;</span><br><span class="line">For example:</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] RAM [<span class="number">0</span>:<span class="number">4095</span>]; <span class="comment">// memory array</span></span><br></pre></td></tr></table></figure>

<p>verilog-2001 对数组的支持进行了增强：</p>
<ul>
<li>支持任何变量或者net 类型，不支持event 类型。</li>
<li>支持3维数组的使用</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 1-dimensional unpacked array of</span></span><br><span class="line"><span class="comment">// 1024 1-bit nets</span></span><br><span class="line"><span class="keyword">wire</span> n [<span class="number">0</span>:<span class="number">1023</span>];</span><br><span class="line"><span class="comment">// a 1-dimensional unpacked array of</span></span><br><span class="line"><span class="comment">// 256 8-bit variables</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] LUT [<span class="number">0</span>:<span class="number">255</span>];</span><br><span class="line"><span class="comment">// a 1-dimensional unpacked array of </span></span><br><span class="line"><span class="comment">// 1024 real variables</span></span><br><span class="line"><span class="keyword">real</span> r [<span class="number">0</span>:<span class="number">1023</span>];</span><br><span class="line"><span class="comment">// a 3-dimensional unpacked array of</span></span><br><span class="line"><span class="comment">// 32-bit int variables</span></span><br><span class="line"><span class="keyword">integer</span> i [<span class="number">7</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Verilog 一次限制数组访问一个元素</p>
</blockquote>
<p>Verilog 限制对数组同一时间只能访问数组的一个元素，或者单个元素的位选择或部分选择。对数组的多个元素的任何读取或写入都是错误的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i [<span class="number">7</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">integer</span> j;</span><br><span class="line">j = i[<span class="number">3</span>][<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// legal: selects 1 element</span></span><br><span class="line">j = i[<span class="number">3</span>][<span class="number">0</span>]; <span class="comment">// illegal: selects 8 elements</span></span><br></pre></td></tr></table></figure>



<p>system verilog 允许未打包的数组可以是任意类型：</p>
<ul>
<li>支持event</li>
<li>支持logic，bit,byte, int , longint,shortreal,real。</li>
<li>typedef</li>
<li>struct,enum</li>
</ul>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">63</span>:<span class="number">0</span>] d_array [<span class="number">1</span>:<span class="number">128</span>]; <span class="comment">// array of vectors</span></span><br><span class="line"><span class="keyword">shortreal</span> cosines [<span class="number">0</span>:<span class="number">89</span>]; 	<span class="comment">// array of floats</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Mo, Tu, We, Th, Fr, Sa, Su&#125; Week;</span><br><span class="line">Week Year [<span class="number">1</span>:<span class="number">52</span>]; 			<span class="comment">// array of Week types</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SystemVerilog 可以引用数组的全部或切片</p>
</blockquote>
<p>SystemVerilog 还为 Verilog 添加了引用整个解压缩数组或解压缩数组中多个元素的切片的能力。切片是数组的一维内的一个或多个连续编号的元素。这些增强功能可以将整个数组的内容或数组的特定维度复制到另一个数组中。</p>
<blockquote>
<p>拷贝多个元素到未打包的数组中</p>
</blockquote>
<p>为了将多个元素直接复制到一个解包数组中，赋值左侧的数组或数组切片的布局和元素类型必须与右侧的布局和元素类型完全匹配。即元素类型和大小以及复制的维数必须相同。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 [<span class="number">7</span>:<span class="number">0</span>][<span class="number">1023</span>:<span class="number">0</span>]; 	<span class="comment">// unpacked array</span></span><br><span class="line"><span class="keyword">int</span> a2 [<span class="number">1</span>:<span class="number">8</span>][<span class="number">1</span>:<span class="number">1024</span>]; 	<span class="comment">// unpacked array</span></span><br><span class="line">a2 = a1; 				<span class="comment">// copy an entire array</span></span><br><span class="line">a2[<span class="number">3</span>] = a1[<span class="number">0</span>]; 			<span class="comment">// copy a slice of an array</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>简化的解包数组声明</p>
</blockquote>
<p>verilog array declarations</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array [<span class="number">64</span>:<span class="number">83</span>]; 	<span class="comment">//a Verilog array with addresses from 64 to 83</span></span><br></pre></td></tr></table></figure>



<p>system verilog array declarations </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C-style array declarations </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// is equivalent to the declaration:</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data [<span class="number">0</span>:<span class="number">1023</span>];</span><br></pre></td></tr></table></figure>

<p>简化的 C 样式数组声明不能与向量声明（压缩数组）一起使用。以下示例是语法错误。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">32</span>] d; <span class="comment">// illegal vector declaration</span></span><br></pre></td></tr></table></figure>



<h4 id="Packed-arrays"><a href="#Packed-arrays" class="headerlink" title="Packed arrays"></a>Packed arrays</h4><p>Verilog 语言允许从单个位类型（例如 reg 和 wire）创建向量。向量范围在信号名称之前，而unpacked的数组范围在信号名称之后。</p>
<p>1D</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] select;  <span class="comment">// 4-bit &quot;packed array&quot;</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">63</span>:<span class="number">0</span>] data; 	<span class="comment">// 64-bit &quot;packed array&quot;</span></span><br></pre></td></tr></table></figure>

<p>SystemVerilog 允许多维打包数组</p>
<p>M-D</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data; <span class="comment">// 2-D packed array</span></span><br></pre></td></tr></table></figure>



<p><strong>Only bit-wise types can be packed</strong></p>
<p>Packed arrays must be formed using bit-wise types (logic, bit or reg),  other  packed  arrays,  packed  structures,  and  packed  unions. Packed arrays can also be formed from any of the Verilog net data types  (wire, uwire, wand, tri, triand, trior, tri0, tri1  or<br>trireg).</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] crc	;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word;</span><br><span class="line"></span><br><span class="line">data_word [<span class="number">7</span>:<span class="number">0</span>] darray; <span class="comment">//1D packed array of packed structures</span></span><br></pre></td></tr></table></figure>



<h5 id="引用打包数组"><a href="#引用打包数组" class="headerlink" title="引用打包数组"></a>引用打包数组</h5><p>打包数组可以作为一个整体、位选择或部分选择来引用。多维打包数组也可以在切片中引用。切片是数组的一个或多个连续维度。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data; 			<span class="comment">// 2-D packed array</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out = data;	 		<span class="comment">// whole array</span></span><br><span class="line"><span class="keyword">wire</span> sign = data[<span class="number">3</span>][<span class="number">7</span>]; 		<span class="comment">// bit-select</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] nib = data [<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>]; <span class="comment">// part-select</span></span><br><span class="line"><span class="keyword">byte</span> high_byte;</span><br><span class="line"><span class="keyword">assign</span> high_byte = data[<span class="number">3</span>]; 	<span class="comment">// 8-bit slice</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] word;</span><br><span class="line"><span class="keyword">assign</span> word = data[<span class="number">1</span>:<span class="number">0</span>]; 		<span class="comment">// 2 slices</span></span><br></pre></td></tr></table></figure>

<h4 id="Using-packed-and-unpacked-arrays"><a href="#Using-packed-and-unpacked-arrays" class="headerlink" title="Using packed and unpacked arrays"></a>Using packed and unpacked arrays</h4><p>将多维数组声明为打包数组或解包数组的能力为如何表示大量复杂数据提供了极大的灵活性。以下是关于何时使用每种类型的数组的一些一般准则。</p>
<blockquote>
<p>使用解包数组建模：</p>
</blockquote>
<ul>
<li>Arrays  of  byte, int, integer, real,  unpacked  structures,unpacked unions, and other types that are not bit-wise types</li>
<li>Arrays where typically one element at a time is accessed, such as with RAMs and ROMs</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ROM (...);</span><br><span class="line">    <span class="keyword">byte</span> mem [<span class="number">0</span>:<span class="number">4095</span>]; <span class="comment">// unpacked array of bytes</span></span><br><span class="line">    <span class="keyword">assign</span> data = select? mem[address]: ’z;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用打包数组建模:</p>
</blockquote>
<ul>
<li>Vectors made up of 1-bit types (the same as in Verilog)</li>
<li>Vectors where it is useful to access sub-fields of the vector</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] packet; 	<span class="comment">// 40 16-bit words</span></span><br><span class="line">packet = input_stream; 		<span class="comment">// assign to all words</span></span><br><span class="line">data = packet[<span class="number">24</span>]; 			<span class="comment">// select 1 16-bit word</span></span><br><span class="line">tag = packet[<span class="number">3</span>][<span class="number">7</span>:<span class="number">0</span>]; 		<span class="comment">// select part of 1 word</span></span><br></pre></td></tr></table></figure>

<h4 id="声明数组时初始化"><a href="#声明数组时初始化" class="headerlink" title="声明数组时初始化"></a>声明数组时初始化</h4><h5 id="Packed-数组初始化"><a href="#Packed-数组初始化" class="headerlink" title="Packed 数组初始化"></a>Packed 数组初始化</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a = <span class="number">32</span>’h0; <span class="comment">// vector assignment</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] b = &#123;<span class="number">16</span>’hz,<span class="number">16</span>’h0&#125;; <span class="comment">// concatenate operator</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] c = &#123;<span class="number">16</span>&#123;<span class="number">2</span>’b01&#125;&#125;; <span class="comment">// replicate operator</span></span><br></pre></td></tr></table></figure>

<h5 id="Unpacked-数组初始化"><a href="#Unpacked-数组初始化" class="headerlink" title="Unpacked 数组初始化"></a>Unpacked 数组初始化</h5><p>解压数组可以在声明时初始化，使用包含在每个数组维度的 ‘{ 和 } 大括号之间的值列表。此语法类似于将值列表分配给 C 中的数组，但在左大括号之前添加了撇号。使用 ‘{ 作为开始分隔符表明封闭的值是表达式列表，而不是表达式的 Verilog 连接。请注意，省略内括号的 C 快捷方式在 SystemVerilog 中是不允许的。该赋值需要嵌套的大括号集，它们与数组的维度完全匹配。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d [<span class="number">0</span>:<span class="number">1</span>][<span class="number">0</span>:<span class="number">3</span>] = ’&#123; ’&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>&#125;, ’&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// d[0][0] = 7 </span></span><br><span class="line"><span class="comment">// d[0][1] = 3 </span></span><br><span class="line"><span class="comment">// d[0][2] = 0 </span></span><br><span class="line"><span class="comment">// d[0][3] = 5 </span></span><br><span class="line"><span class="comment">// d[1][0] = 2 </span></span><br><span class="line"><span class="comment">// d[1][1] = 0 </span></span><br><span class="line"><span class="comment">// d[1][2] = 1 </span></span><br><span class="line"><span class="comment">// d[1][3] = 6 </span></span><br></pre></td></tr></table></figure>

<p>SystemVerilog 提供了声明值列表的快捷方式。数组的一维内部列表可以使用类似 Verilog 的复制因子重复任意次数。复制因子后面没有撇号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e [<span class="number">0</span>:<span class="number">1</span>][<span class="number">0</span>:<span class="number">3</span>] = ’&#123; <span class="number">2</span>&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// e[0][0] = 7 </span></span><br><span class="line"><span class="comment">// e[0][1] = 3 </span></span><br><span class="line"><span class="comment">// e[0][2] = 0 </span></span><br><span class="line"><span class="comment">// e[0][3] = 5 </span></span><br><span class="line"><span class="comment">// e[1][0] = 7 </span></span><br><span class="line"><span class="comment">// e[1][1] = 3 </span></span><br><span class="line"><span class="comment">// e[1][2] = 0 </span></span><br><span class="line"><span class="comment">// e[1][3] = 5</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：The ’{ } list and ’{n{ }}  replicated list operators are not the same  as  the  Verilog  { }   concatenate  and  {n{ }}   replicate operators.</p>
<h4 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h4><h5 id="Unpacked-arrays-赋值"><a href="#Unpacked-arrays-赋值" class="headerlink" title="Unpacked arrays 赋值"></a>Unpacked arrays 赋值</h5><p>Verilog 语言支持两种给解压数组赋值的方法：</p>
<ul>
<li>单个元素的赋值方法</li>
<li>可以为单个元素的位选择或部分选择分配一个值（作为 Verilog-2001 标准的一部分添加）。可以将数组初始化为默认值</li>
</ul>
<p>SystemVerilog 扩展了 Verilog，增加了两种将值分配给解包数组的方法</p>
<ul>
<li>可以为整个数组分配一个值列表。 </li>
<li>可以为数组的一个切片分配一个值列表</li>
</ul>
<p>The  list  of  values  is  specified  between  ’{ }  braces,  the  same  as with  initializing  unpacked  arrays,  as  discussed  in  section  5.3.4  on page 119.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a [<span class="number">0</span>:<span class="number">3</span>][<span class="number">0</span>:<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">8</span>’h5; <span class="comment">// assign to one element</span></span><br><span class="line">a = ’&#123;’&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    ’&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    ’&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    ’&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// assign a list of values to the full array</span></span><br><span class="line">a[<span class="number">3</span>] = ’&#123;’hF, ’hA, ’hC, ’hE&#125;;</span><br><span class="line"><span class="comment">// assign list of values to slice of the array</span></span><br></pre></td></tr></table></figure>

<p>example2：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using  the  default  keyword</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    <span class="keyword">if</span> (!resetN) <span class="keyword">begin</span></span><br><span class="line">        a = ’&#123;<span class="keyword">default</span>:<span class="number">0</span>&#125;;    <span class="comment">// init entire array</span></span><br><span class="line">        a[<span class="number">0</span>] = ’&#123;<span class="keyword">default</span>:<span class="number">4</span>&#125;; <span class="comment">// init slice of array</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="Packed-arrays-赋值"><a href="#Packed-arrays-赋值" class="headerlink" title="Packed arrays 赋值"></a>Packed arrays 赋值</h5><p>压缩数组是向量（可能恰好有子字段），并且可以赋值，就像 Verilog 向量一样。可以为打包数组分配一个值：</p>
<ul>
<li><p>到数组的一个元素</p>
</li>
<li><p> 到整个数组（向量）</p>
</li>
<li><p>To a part select of the array</p>
</li>
<li><p>To a slice (multiple contiguous sub-fields) of the array</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>][<span class="number">1</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a; 	<span class="comment">// 3-D packed array</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>’b0; 			<span class="comment">// assign to one bit</span></span><br><span class="line">a = <span class="number">32</span>’hF1A3C5E7; 			<span class="comment">// assign to full array</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>] = <span class="number">4</span>’hF; 		<span class="comment">// assign to a part select</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">16</span>’hFACE; 			<span class="comment">// assign to a slice</span></span><br><span class="line">a = &#123;<span class="number">16</span>’bz, <span class="number">16</span>’b0&#125;; 		<span class="comment">// assign concatenation </span></span><br></pre></td></tr></table></figure>

<h4 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h4><p>assigning packed array to packed array is allowed：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] a; <span class="comment">// 32 bit 2-state vector</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][ <span class="number">7</span>:<span class="number">0</span>] b; <span class="comment">// 32 bit 4-state vector</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] c; <span class="comment">// 16 bit 4-state vector</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>] d; <span class="comment">// 40 bit 4-state vector</span></span><br><span class="line">b = a; <span class="comment">// assign 32-bit array to 32-bit array</span></span><br><span class="line">c = a; <span class="comment">// upper 16 bits will be truncated</span></span><br><span class="line">d = a; <span class="comment">// upper 8 bits will be zero filled</span></span><br></pre></td></tr></table></figure>

<p>assigning unpacked array to unpacked array is allowed</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a [<span class="number">2</span>:<span class="number">0</span>][<span class="number">9</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">0</span>:<span class="number">31</span>] b [<span class="number">1</span>:<span class="number">3</span>][<span class="number">1</span>:<span class="number">10</span>]; </span><br><span class="line">a = b; <span class="comment">// assign unpacked array to unpacked array</span></span><br></pre></td></tr></table></figure>

<p>assigning unpacked arrays of different sizes requires casting</p>
<p>assigning unpacked arrays to packed arrays requires casting</p>
<p>assigning packed arrays to unpacked arrays requires casting</p>
<h4 id="将用户定义的类型与数组一起使用"><a href="#将用户定义的类型与数组一起使用" class="headerlink" title="将用户定义的类型与数组一起使用"></a>将用户定义的类型与数组一起使用</h4><p>用户定义的类型可以用作数组的元素。下面的例子定义了一个无符号整数的用户类型，并声明了一个由 128 个无符号整数组成的解压数组。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> uint;</span><br><span class="line">uint u_array [<span class="number">0</span>:<span class="number">127</span>]; <span class="comment">// array of user types</span></span><br></pre></td></tr></table></figure>

<p>User-defined  types  can  also  be  defined  from  an  array  definition. These user types can then be used in other array definitions, creating a compound array.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] nibble; <span class="comment">// packed array</span></span><br><span class="line">nibble [<span class="number">31</span>:<span class="number">0</span>] big_word; <span class="comment">// packed array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The preceding example is equivalent to:</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>] big_word;</span><br></pre></td></tr></table></figure>

<p>Another  example  of  a  compound  array  built  up  from  user-defined types is:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] nibble; <span class="comment">// packed array</span></span><br><span class="line"><span class="keyword">typedef</span> nibble nib_array [<span class="number">0</span>:<span class="number">3</span>]; <span class="comment">// unpacked</span></span><br><span class="line">nib_array compound_array [<span class="number">0</span>:<span class="number">7</span>]; <span class="comment">// unpacked</span></span><br><span class="line">This last example is equivalent to:</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] compound_array [<span class="number">0</span>:<span class="number">7</span>][<span class="number">0</span>:<span class="number">3</span>];</span><br></pre></td></tr></table></figure>



<h4 id="综合指南-3"><a href="#综合指南-3" class="headerlink" title="综合指南"></a>综合指南</h4><p>数组和涉及数组的赋值是可综合的。具体来说：数组可以包含结构或联合 结构和联合可以包含数组：</p>
<ul>
<li>Arrays declarations — Both unpacked and packed arrays are synthesizable. The arrays can have any number of dimensions.</li>
<li>Assigning values to arrays — synthesis supports assigning values to individual elements of an array, bit-selects or part-selects of an array element, array slices, or entire arrays. Assigning lists of literal values to arrays is also synthesizable, including literals using the <strong>default</strong> keyword. </li>
<li>Copying  arrays  —  Synthesis  supports  packed  arrays  directly assigned  to  packed  arrays.  Synthesis  also  supports  unpacked arrays  directly  assigned  to  unpacked  arrays  of  the  same  layout. Assigning any type of array to any type of array using bit-stream casting is also synthesizable.</li>
<li>Arrays in structures and unions — The use of arrays within structures and unions is synthesizable. <strong>Unions</strong> must be <strong>packed</strong>, which means arrays within the union must be packed).</li>
<li>Arrays of structures or unions — Arrays of structures and arrays of unions are synthesizable (unions must be packed). A structure or  union  must  be  typed  (using  <strong>typedef</strong>)  in  order  to  define  an array of the <strong>structure</strong> or <strong>union</strong>.</li>
<li>Passing  arrays  —  Arrays  passed  through  <strong>module  ports</strong>,  or  as arguments to a <strong>task</strong> or <strong>function</strong>, is <strong>synthesizable</strong></li>
</ul>
<h4 id="使用数组的示例"><a href="#使用数组的示例" class="headerlink" title="使用数组的示例"></a>使用数组的示例</h4><p>以下示例使用 32 条指令的压缩数组对指令寄存器进行建模。每条指令都是一个复合值，表示为一个压缩结构。指令中的操作数可以是有符号或无符号的，它们表示为两种类型的并集。该指令寄存器的输入是单独的操作数、操作码和指示操作数是有符号还是无符号的标志。该模型将这些单独的信息加载到指令寄存器中。模型的输出是 32 条指令的数组</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MULT, DIV, SL, SR&#125; opcode_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNSIGNED, SIGNED&#125; operand_type_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">union</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] u_data;</span><br><span class="line">		<span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">31</span>:<span class="number">0</span>] s_data;</span><br><span class="line">	&#125; data_t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        opcode_t opc;</span><br><span class="line">        operand_type_t op_type;</span><br><span class="line">        data_t op_a;</span><br><span class="line">        data_t op_b;</span><br><span class="line">    &#125; instr_t;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> definitions::*; <span class="comment">// import package into $unit space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> instruction_register (</span><br><span class="line">        <span class="keyword">output</span> instr_t [<span class="number">0</span>:<span class="number">31</span>] instr_reg, <span class="comment">// packed array of structures</span></span><br><span class="line">        <span class="keyword">input</span> data_t operand_a,</span><br><span class="line">        <span class="keyword">input</span> data_t operand_b,</span><br><span class="line">        <span class="keyword">input</span> operand_type_t op_type,</span><br><span class="line">        <span class="keyword">input</span> opcode_t opcode,</span><br><span class="line">        <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] write_pointer</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">always</span> @(write_pointer) <span class="keyword">begin</span></span><br><span class="line">        instr_reg[write_pointer]<span class="variable">.op_type</span> = op_type;</span><br><span class="line">        instr_reg[write_pointer]<span class="variable">.opc</span>     = opcode;</span><br><span class="line">        <span class="comment">// use op_type to determine the operand type stored</span></span><br><span class="line">        <span class="comment">// in the input operand union</span></span><br><span class="line">        <span class="keyword">if</span> (op_type == SIGNED) <span class="keyword">begin</span></span><br><span class="line">            instr_reg[write_pointer]<span class="variable">.op_a</span><span class="variable">.s_data</span> = operand_a<span class="variable">.s_data</span>;</span><br><span class="line">            instr_reg[write_pointer]<span class="variable">.op_b</span><span class="variable">.s_data</span> = operand_b<span class="variable">.s_data</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            instr_reg[write_pointer]<span class="variable">.op_a</span><span class="variable">.u_data</span> = operand_a<span class="variable">.u_data</span>;</span><br><span class="line">            instr_reg[write_pointer]<span class="variable">.op_b</span><span class="variable">.u_data</span> = operand_b<span class="variable">.u_data</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="foreach-数组循环结构"><a href="#foreach-数组循环结构" class="headerlink" title="foreach 数组循环结构"></a>foreach 数组循环结构</h3><h2 id="第六章-SystemVerilog-程序块、任务和函数"><a href="#第六章-SystemVerilog-程序块、任务和函数" class="headerlink" title="第六章 SystemVerilog 程序块、任务和函数"></a>第六章 SystemVerilog 程序块、任务和函数</h2><h3 id="Verilog-中的always块"><a href="#Verilog-中的always块" class="headerlink" title="Verilog 中的always块"></a>Verilog 中的always块</h3><h3 id="system-verilog-中的-procedural-block"><a href="#system-verilog-中的-procedural-block" class="headerlink" title="system verilog 中的  procedural  block"></a>system verilog 中的  procedural  block</h3><h4 id="always-comb"><a href="#always-comb" class="headerlink" title="always_comb"></a>always_comb</h4><p>always_comb 可以推断信号敏感列表:</p>
<p>SystemVerilog 还在敏感列表中包括由从程序块调用的函数读取的任何信号，除了仅在函数内分配和读取的临时变量。</p>
<p>always_comb 对于仿真的增强：</p>
<p>always_comb 程序块也不同于一般的 always 程序块，因为 always_comb 程序块将在仿真时间为零时自动触发一次，在所有初始和 always 程序块都被激活之后。无论推断的灵敏度列表中的信号是否有任何变化，都会发生这种自动评估。 always_comb 的这种特殊语义可确保组合逻辑的输出与仿真时间为零时逻辑的输入值一致。在使用 2 态变量建模时，默认情况下，以逻辑 0 开始仿真，这种在零时间的自动评估可能尤其重要。复位可能不会导致组合逻辑灵敏度列表中的信号发生事件。如果没有事件，则不会触发通用的始终过程块，因此不会更新输出变量。</p>
<p>以下示例说明了 always_comb 和通用 always 程序块之间的这种差异。该模型表示使用枚举类型建模的简单有限状态机。三种可能的状态是等待、加载和存储。当状态机复位时，它返回到等待状态。状态机的组合逻辑对当前状态进行解码，如果当前状态为 WAITE，则将下一个状态设置为 LOAD。在时钟的每个上升沿，状态序列逻辑将 State 变量设置为 NextState 变量的值。</p>
<p>verilog always block 6-1</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simulation have problem</span></span><br><span class="line"><span class="keyword">module</span> controller (<span class="keyword">output</span> <span class="keyword">logic</span> read, write,</span><br><span class="line">                   <span class="keyword">input</span> instr_t instruction,</span><br><span class="line">                   <span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> &#123;WAITE, LOAD, STORE&#125; State, NextState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">        <span class="keyword">if</span> (!resetN) State &lt;= WAITE;</span><br><span class="line">        <span class="keyword">else</span> State &lt;= NextState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(State) <span class="keyword">begin</span>	<span class="comment">//Only triggers when state changes value</span></span><br><span class="line">        <span class="keyword">case</span> (State)</span><br><span class="line">            WAITE: NextState = LOAD;</span><br><span class="line">            LOAD: NextState = STORE;</span><br><span class="line">            STORE: NextState = WAITE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(State, instruction) <span class="keyword">begin</span></span><br><span class="line">        read = <span class="number">0</span>; write = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (State == LOAD &amp;&amp; instruction == FETCH) read = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (State == STORE &amp;&amp; instruction == WRITE) write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>示例 6-1 中有一个模拟的细微之处。在仿真时间为零时，枚举类型默认为枚举类型的基类型的默认值。除非另有明确声明，否则基本类型是 2 状态 int 类型。 int 开始模拟时的初始值为 0，这也是枚举值列表中的 WAITE 值。因此，State 变量和 NextState 变量都默认为 WAITE 的值。在时钟的上升沿，状态序列逻辑将 State 设置为 NextState。但是，由于两个变量具有相同的值，因此状态实际上并没有改变。由于 State 没有更改，因此始终 @(State) 程序块不会触发，并且 NextState 变量不会更新为新值。该模型的模拟被锁定，因为 State 和 NextState 变量具有相同的值。即使应用了重置，此问题仍然存在。重置会将 State 设置为 WAITE 的值，该值与其当前值相同。由于 State 没有改变，因此始终 @(State) 程序块不会触发，从而使 State 和 NextState 具有相同值的问题持续存在。</p>
<p>由于 Verilog 敏感度列表的工作方式，这个锁定状态问题是一个模拟异常。这个问题在实际硬件中不存在，甚至硬件的门级模型也不存在。在实际硬件中，组合逻辑的输出将反映该逻辑的输入值。如果硬件解码器的输入具有 WAITE 的值，则输出 NextState 将是 LOAD 的值。然而，在抽象的 RTL 模拟中，NextState 不能正确反映组合解码器逻辑的输入，因为在模拟时间为零时，没有任何东西触发程序块导致 NextState 从其默认初始值更新。</p>
<p>下面的示例 6-2 对该示例进行了一个简单的更改。总是 @(State) 被替换为 always_comb。 always_comb 程序块将推断块读取的所有外部变量的敏感度列表，在本例中为状态。因此，always_comb 推断出与示例 6-1 中相同的敏感度列表：</p>
<p>即使敏感度列表相同，always_comb 和使用 always @(State) 之间也有重要区别。在激活所有程序块之后，always_comb 程序块会在仿真时间为零时自动执行一次。在此示例中，这意味着在仿真时间为零时，NextState 将被更新以反映在时间为零时的状态值。 当时钟的第一个上升沿出现时，State 将转换为 NextState 的值，这是一个不同的值。 这将触发 always_comb 过程，然后更新 NextState 以反映 State 的新值。 使用 always_comb，就不会出现示例 6-1 中所示的模拟锁定问题。</p>
<p>system veriog  always_comb  6-2</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this modle not have above problem</span></span><br><span class="line"><span class="keyword">module</span> controller (<span class="keyword">output</span> <span class="keyword">logic</span> read, write,</span><br><span class="line">    <span class="keyword">input</span> instr_t instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> &#123;WAITE, LOAD, STORE&#125; State, NextState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">        <span class="keyword">if</span> (!resetN) State &lt;= WAITE;</span><br><span class="line">        <span class="keyword">else</span> State &lt;= NextState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span> <span class="comment">//infers @(State) — the block automatically executes once at time zero, even if not triggered</span></span><br><span class="line">        <span class="keyword">case</span> (State)</span><br><span class="line">            WAITE: NextState = LOAD;</span><br><span class="line">            LOAD: NextState = STORE;</span><br><span class="line">            STORE: NextState = WAITE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        read = <span class="number">0</span>; write = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (State == LOAD &amp;&amp; instruction == FETCH) read = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (State == STORE &amp;&amp; instruction == WRITE) write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="always-ff"><a href="#always-ff" class="headerlink" title="always_ff"></a>always_ff</h4><p>always_ff 专用程序块表明设计者的意图是对可综合的时序逻辑行为进行建模。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">    <span class="keyword">if</span> (!resetN) q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> q &lt;= d;</span><br></pre></td></tr></table></figure>

<p>通过使用 always_ff 对时序逻辑进行建模，软件工具无需检查程序块的内容来尝试推断预期的逻辑类型。通过专用程序块类型清楚地表明意图，软件工具可以改为检查程序块的内容，并在内容不能合成为顺序逻辑时发出警告。与 always_comb 和 always_latch 一样，这些对 always_ff 程序块内容的附加语义检查是可选的。</p>
<p><strong>顺序逻辑灵敏度列表</strong></p>
<p>always_ff 程序块要求灵敏度列表中的每个信号都必须使用 posedge 或 negedge 进行限定。这是时序逻辑灵敏度列表的综合要求。将此规则作为句法要求有助于确保仿真结果与综合结果相匹配。 always_ff 程序块还禁止在程序块开头以外的任何地方使用事件控件。程序块内的事件控件不代表程序块的敏感度列表，因此是不允许的。这也是时序逻辑 RTL 模型的综合要求。</p>
<h4 id="always-latch"><a href="#always-latch" class="headerlink" title="always_latch"></a>always_latch</h4><p><strong>使用 always_latch 程序块的示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> register_reader (<span class="keyword">input</span> clk, ready, resetN,</span><br><span class="line">						<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] read_pointer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">logic</span> enable; <span class="comment">// internal enable signal for the counter</span></span><br><span class="line">    <span class="keyword">logic</span> overflow; <span class="comment">// internal counter overflow flag</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_latch</span> <span class="keyword">begin</span> <span class="comment">// latch the ready input</span></span><br><span class="line">        <span class="keyword">if</span> (!resetN)</span><br><span class="line">        	enable &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ready)</span><br><span class="line">        	enable &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (overflow)</span><br><span class="line">        	enable &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">negedge</span> resetN) <span class="keyword">begin</span> <span class="comment">// 5-bit counter</span></span><br><span class="line">            <span class="keyword">if</span> (!resetN)</span><br><span class="line">           	 	&#123;overflow,read_pointer&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (enable)</span><br><span class="line">            	&#123;overflow,read_pointer&#125; &lt;= read_pointer + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="综合指南-4"><a href="#综合指南-4" class="headerlink" title="综合指南"></a>综合指南</h4><p>专用的 always_comb、always_latch 和 always_ff 程序块是可合成的。 无论何时打算将模型与仿真和综合工具一起使用，这些专用程序块都是比 Verilog 的通用始终程序块更好的建模选择。 专用程序块需要模拟器和其他软件工具来检查综合编译器所需的规则。 使用 always_comb、always_latch 和 always_ff 程序块有助于在模型准备好合成之前，在设计过程的早期消除潜在的建模错误。。</p>
<h3 id="增强的tasks-与-functions"><a href="#增强的tasks-与-functions" class="headerlink" title="增强的tasks 与 functions"></a>增强的tasks 与 functions</h3><h4 id="隐式的任务和函数语句组"><a href="#隐式的任务和函数语句组" class="headerlink" title="隐式的任务和函数语句组"></a>隐式的任务和函数语句组</h4><p><strong>begin…end groups multiple statements</strong> </p>
<p>在 Verilog 中，任务或函数中的多个语句必须使用 begin…end 进行分组。任务还允许使用 fork…join 对多个语句进行分组。</p>
<p><strong>SystemVerilog infers begin…end</strong></p>
<p>SystemVerilog 简化了任务和函数定义，不需要对多个语句进行 begin…end 分组。如果省略分组，则任务或函数中的多个语句将按顺序执行，就像在 begin…end 块中一样。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> states_t NextState(states_t State);</span><br><span class="line">    NextState = State; <span class="comment">// default next state</span></span><br><span class="line">    <span class="keyword">case</span> (State)</span><br><span class="line">        WAITE: <span class="keyword">if</span> (start) NextState = LOAD;</span><br><span class="line">        LOAD: <span class="keyword">if</span> (done) NextState = STORE;</span><br><span class="line">        STORE: NextState = WAITE;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>



<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>functions create an implied variable of the same name and type</strong></p>
<p>在 Verilog 中，函数名本身是一个推断变量，与函数的类型相同。函数的返回值是通过为函数的名称赋值来设置的。当执行流程到达函数末尾时，函数退出。写入函数名称的推断变量的最后一个值是函数返回的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">31</span>:<span class="number">0</span>] add_and_inc (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,b);</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    	add_and_inc = a + b + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>SystemVerilog adds a <strong>return</strong> statement, which allows functions to return a value using <strong>return</strong>, as in C.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add_and_inc (<span class="keyword">input</span> <span class="keyword">int</span> a, b);</span><br><span class="line">	<span class="keyword">return</span> a + b + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p><strong>return 优先于返回函数名中的值</strong></p>
<p>为了保持与 Verilog 的向后兼容性，可以使用 return 语句或分配给函数名称来指定函数的返回值。 return 语句优先。如果执行了 return 语句，那就是返回的值。如果在没有执行 return 语句的情况下到达函数的末尾，那么分配给函数名的最后一个值就是返回值，就像在 Verilog 中一样。即使在使用return语句时，函数名仍然是一个推断变量，可以在执行return语句之前作为临时存储。例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add_and_inc (<span class="keyword">input</span> <span class="keyword">int</span> a, b);</span><br><span class="line">    add_and_inc = a + b;</span><br><span class="line">    <span class="keyword">return</span> ++add_and_inc;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<h4 id="在任务和功能结束前返回"><a href="#在任务和功能结束前返回" class="headerlink" title="在任务和功能结束前返回"></a>在任务和功能结束前返回</h4><p><strong>Verilog 必须到达任务或函数的末尾才能退出</strong></p>
<p>在 Verilog 中，任务或函数在执行流程到达结束时退出，用 endtask 或 endfunction 表示。为了在使用 Verilog 到达任务或函数结束之前退出，必须使用 if…else 等条件语句来强制执行流程跳转到任务或函数的末尾。也可以使用 disable 关键字强制任务跳转到其末尾，但这会影响所有当前正在运行的重入任务调用。<strong>以下示例</strong>需要额外编码以防止在函数的输入小于或等于 1 时执行该函数</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> log2 (<span class="keyword">input</span> <span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>)</span><br><span class="line">    	log2 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// skip this code when n&lt;=1</span></span><br><span class="line">        log2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">            log2 = log2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p><strong>return 语句可用于在结束前退出 Verilog 函数必须返回值 void 函数不返回值</strong></p>
<p>SystemVerilog <strong>return</strong> 语句可用于在执行流程中随时退出任务或函数，而不必到达任务或函数的末尾。使用<strong>return</strong>，上面的例子可以简化如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> log2 (<span class="keyword">input</span> <span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// abort function</span></span><br><span class="line">    	log2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    	n = n/<span class="number">2</span>;</span><br><span class="line">    	log2++;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>使用 return 在到达结束之前退出任务或函数可以简化任务或函数内的编码，并使执行流程更加直观和可读。</p>
<h2 id="第十章-system-Verilog-Interfaces"><a href="#第十章-system-Verilog-Interfaces" class="headerlink" title="第十章 system Verilog Interfaces"></a>第十章 system Verilog Interfaces</h2><p>SystemVerilog 使用强大的接口结构扩展了 Verilog 语言。接口为建模抽象提供了一种新的范式。使用接口可以简化大型复杂设计的建模和验证任务。</p>
<p>本章包含许多小示例，每个示例都显示了接口的特定功能。这些示例故意保持相对较小和简单，以便专注于界面的特定功能。然后第 11 章展示了一个更大的示例，该示例在更完整的设计环境中使用接口</p>
<h3 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h3><p>Verilog 语言通过模块端口将模块连接在一起。这是一种表示设计块之间连接的详细方法，该设计直接映射到实际硬件中的物理连接。然而，对于大型设计，使用模块端口将设计块连接在一起可能会变得乏味和冗余。考虑以下示例，该示例使用称为 main_bus 的基本总线架构将设计的五个模块连接在一起，以及一些设计模块之间的一些附加连接。图 10-1 显示了这个简单设计的框图，示例 10-1 列出了涉及的模块声明的 Verilog 源代码。</p>
<p><img src="/2022/01/19/SystemVerilog-For-Design-note/image-20220203152443820.png" alt="image-20220203152443820"></p>
<p>Example10-1  Verilog module interconnections for a simple design</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************** Top-level Netlist ********************/</span></span><br><span class="line"><span class="keyword">module</span> top (<span class="keyword">input</span> <span class="keyword">wire</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data, address, program_address, jump_address;</span><br><span class="line">    <span class="keyword">wire</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction, next_instruction;</span><br><span class="line">    <span class="keyword">wire</span> [ <span class="number">3</span>:<span class="number">0</span>] slave_instruction;</span><br><span class="line">    <span class="keyword">wire</span> slave_request, slave_ready;</span><br><span class="line">    <span class="keyword">wire</span> bus_request, bus_grant;</span><br><span class="line">    <span class="keyword">wire</span> mem_read, mem_write;</span><br><span class="line">    <span class="keyword">wire</span> data_ready;</span><br><span class="line">    </span><br><span class="line">    processor proc1 ( </span><br><span class="line">        <span class="comment">// main_bus ports			//signals for main_bus must be individually connected  to each module instance</span></span><br><span class="line">        <span class="variable">.data</span>(data),</span><br><span class="line">        <span class="variable">.address</span>(address),</span><br><span class="line">        <span class="variable">.slave_instruction</span>(slave_instruction),</span><br><span class="line">        <span class="variable">.slave_request</span>(slave_request),</span><br><span class="line">        <span class="variable">.bus_grant</span>(bus_grant),</span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),</span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),</span><br><span class="line">        <span class="variable">.bus_request</span>(bus_request),</span><br><span class="line">        <span class="variable">.slave_ready</span>(slave_ready),</span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.jump_address</span>(jump_address),</span><br><span class="line">        <span class="variable">.instruction</span>(instruction),</span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN),</span><br><span class="line">        <span class="variable">.test_mode</span>(test_mode)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    slave slave1 (</span><br><span class="line">        <span class="comment">// main_bus ports  main_bus connections</span></span><br><span class="line">        <span class="variable">.data</span>(data),</span><br><span class="line">        <span class="variable">.address</span>(address),</span><br><span class="line">        <span class="variable">.bus_request</span>(bus_request),</span><br><span class="line">        <span class="variable">.slave_ready</span>(slave_ready),</span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),</span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),</span><br><span class="line">        <span class="variable">.slave_instruction</span>(slave_instruction),</span><br><span class="line">        <span class="variable">.slave_request</span>(slave_request),</span><br><span class="line">        <span class="variable">.bus_grant</span>(bus_grant),</span><br><span class="line">        <span class="variable">.data_ready</span>(data_ready),</span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN)</span><br><span class="line">    );   </span><br><span class="line"></span><br><span class="line">    dual_port_ram ram (</span><br><span class="line">        <span class="comment">// main_bus ports main_bus connections</span></span><br><span class="line">        <span class="variable">.data</span>(data),</span><br><span class="line">        <span class="variable">.data_ready</span>(data_ready),</span><br><span class="line">        <span class="variable">.address</span>(address),</span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),</span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),</span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.program_address</span>(program_address),</span><br><span class="line">        <span class="variable">.data_b</span>(next_instruction)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    test_generator test_gen(</span><br><span class="line">        <span class="comment">// main_bus ports //main_bus connections</span></span><br><span class="line">        <span class="variable">.data</span>(data),</span><br><span class="line">        <span class="variable">.address</span>(address),</span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),</span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),</span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN),</span><br><span class="line">        <span class="variable">.test_mode</span>(test_mode)</span><br><span class="line">    );   </span><br><span class="line">  </span><br><span class="line">    instruction_reg ir (</span><br><span class="line">        <span class="variable">.program_address</span>(program_address),</span><br><span class="line">        <span class="variable">.instruction</span>(instruction),</span><br><span class="line">        <span class="variable">.jump_address</span>(jump_address),</span><br><span class="line">        <span class="variable">.next_instruction</span>(next_instruction),</span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/********************* Module Definitions ********************/</span></span><br><span class="line"><span class="keyword">module</span> processor (</span><br><span class="line">    <span class="comment">// main_bus ports</span></span><br><span class="line">    <span class="keyword">inout</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [ <span class="number">3</span>:<span class="number">0</span>] slave_instruction,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> slave_request,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> bus_grant,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> mem_read,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> mem_write,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> bus_request,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> slave_ready,</span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] jump_address,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> resetN,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> test_mode</span><br><span class="line">);</span><br><span class="line">	... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> slave (</span><br><span class="line">    <span class="comment">// main_bus ports</span></span><br><span class="line">    <span class="keyword">inout</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data,</span><br><span class="line">    <span class="keyword">inout</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> bus_request,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> slave_ready,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> mem_read,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> mem_write,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [ <span class="number">3</span>:<span class="number">0</span>] slave_instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> slave_request,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> bus_grant,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> data_ready,</span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> resetN</span><br><span class="line">    );</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dual_port_ram (</span><br><span class="line">    <span class="comment">// main_bus ports</span></span><br><span class="line">    <span class="keyword">inout</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> data_ready,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">tri0</span> mem_read,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">tri0</span> mem_write,</span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] program_address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [ <span class="number">7</span>:<span class="number">0</span>] data_b</span><br><span class="line">);</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test_generator (</span><br><span class="line">    <span class="comment">// main_bus ports</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_read,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_write,</span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> resetN,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> test_mode</span><br><span class="line">);</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> instruction_reg (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] program_address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] jump_address,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [ <span class="number">7</span>:<span class="number">0</span>] next_instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> resetN</span><br><span class="line">);</span><br><span class="line">	... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="Verilog模块端口的缺点"><a href="#Verilog模块端口的缺点" class="headerlink" title="Verilog模块端口的缺点"></a>Verilog模块端口的缺点</h4><p>Verilog 的模块端口提供了一种简单直观的方式来描述设计块之间的互连。然而，在大型、复杂的设计中，Verilog 的模块端口有几个缺点。其中一些是：</p>
<ul>
<li>声明必须在多个模块中重复。 </li>
<li>通信协议必须在多个模块中重复。 </li>
<li>不同模块中存在不匹配声明的风险。 </li>
<li>设计规范的更改可能需要对多个模块进行修改</li>
</ul>
<p><strong>在网表中连接模块需要冗余端口声明</strong></p>
<p>使用 Verilog 的模块端口将设计的主要模块连接在一起的一个缺点在上面的示例代码中很明显。必须在使用总线的每个模块以及将设计连接在一起的顶级网表中声明构成上例中的 main_bus 的信号。在这个简单的例子中，main_bus 中只有少数几个信号，所以多余的声明大多只是一种不便。然而，在大型、复杂的设计中，这种冗余不仅仅是一种不便。一个大型设计可能有几十个模块连接到同一条总线，每个模块中有几十个重复的声明。如果一个模块的端口无意中被声明为与设计的其余部分不同，则可能会出现难以发现的功能错误。</p>
<p>复制的端口声明还意味着，如果总线规范在设计过程中或在下一代设计中发生变化，因此，必须更改共享总线的每个模块。 还必须更改用于使用总线连接模块的所有网表。 hange 的这种广泛传播效果与良好的编码风格背道而驰。 编码的一个目标是以这样一种方式构建代码，即一个地方的微小变化不应该需要改变代码的其他区域。 Verilog 语言的一个弱点是对一个模块中的端口的更改通常需要对其他模块进行更改。 </p>
<p><strong>协议必须在每个模块中重复</strong></p>
<p>Verilog 模块端口的另一个缺点是，必须在每个模块中复制通信协议，以利用模块之间的互连信号。例如，如果三个模块从共享存储设备读取和写入，则必须在每个模块中复制读取和写入控制逻辑。</p>
<p><strong>模块端口抑制抽象的自上而下设计</strong></p>
<p>使用模块端口将设计块连接在一起的另一个缺点是，必须在设计周期的早期确定设计的详细互连。这与自上而下的设计范式背道而驰，在这种范式中，模型首先是在抽象级别编写的，没有广泛的设计细节。在抽象层面上，互连总线不应该需要定义构成总线的每个信号。事实上，在设计规范的早期，我们所知道的只是设计的块将共享某些信息。在第 264 页的图 10-1 所示的框图中，main_bus 表示为单个连接。然而，使用 Verilog 的模块端口将设计块连接在一起，不允许在同一抽象级别进行建模。在对设计的任何模块进行建模之前，必须首先将总线分解为单独的信号。</p>
<h4 id="SystemVerilog-接口的优点"><a href="#SystemVerilog-接口的优点" class="headerlink" title="SystemVerilog 接口的优点"></a>SystemVerilog 接口的优点</h4><p><strong>接口是一种抽象端口类型</strong></p>
<p>SystemVerilog 为 Verilog 添加了一个强大的新端口类型，称为<strong>interface</strong>。interface允许将多个信号组合在一起并表示为单个端口。构成接口的信号声明包含在一个位置。然后，使用这些信号的每个模块都有一个interface类型的端口，而不是许多带有离散信号的端口。</p>
<p>例 10-2 显示了 SystemVerilog 的<strong>interfaces</strong>如何减少为图 10-1 所示的简单设计建模所需的代码量。通过将构成 <strong>main_bus</strong> 的信号封装为接口，消除了每个模块中这些信号的冗余声明。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 10-2: SystemVerilog module interconnections using interfaces</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* Interface Definitions *******************/</span></span><br><span class="line"><span class="keyword">interface</span> main_bus;	<span class="comment">//signals for main_bus are  defined in just one place</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] slave_instruction;</span><br><span class="line">    <span class="keyword">logic</span> slave_request;</span><br><span class="line">    <span class="keyword">logic</span> bus_grant;</span><br><span class="line">    <span class="keyword">logic</span> bus_request;</span><br><span class="line">    <span class="keyword">logic</span> slave_ready;</span><br><span class="line">    <span class="keyword">logic</span> data_ready;</span><br><span class="line">    <span class="keyword">logic</span> mem_read;</span><br><span class="line">    <span class="keyword">logic</span> mem_write;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************** Top-level Netlist ********************/</span></span><br><span class="line"><span class="keyword">module</span> top (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] program_address, jump_address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction, next_instruction;</span><br><span class="line">    main_bus bus ( ); <span class="comment">// instance of an interface (instance name is bus)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    processor proc1 (</span><br><span class="line">        <span class="comment">// main_bus ports	</span></span><br><span class="line">        <span class="comment">//each module instance has a single connection for main_bus</span></span><br><span class="line">        <span class="variable">.bus</span>(bus), <span class="comment">// interface connection</span></span><br><span class="line">        <span class="comment">// other ports </span></span><br><span class="line">        <span class="variable">.jump_address</span>(jump_address),</span><br><span class="line">        <span class="variable">.instruction</span>(instruction),</span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN),</span><br><span class="line">        <span class="variable">.test_mode</span>(test_mode)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    slave slave1 (</span><br><span class="line">        <span class="comment">// main_bus ports</span></span><br><span class="line">        <span class="comment">//    main_bus connections</span></span><br><span class="line">        <span class="variable">.bus</span>(bus), <span class="comment">// interface connection</span></span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN)</span><br><span class="line">    );</span><br><span class="line">    dual_port_ram ram (</span><br><span class="line">        <span class="comment">// main_bus ports</span></span><br><span class="line">        <span class="comment">//    main_bus connections</span></span><br><span class="line">        <span class="variable">.bus</span>(bus), <span class="comment">// interface connection</span></span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.program_address</span>(program_address),</span><br><span class="line">    	<span class="variable">.data_b</span>(next_instruction)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    test_generator test_gen(</span><br><span class="line">        <span class="comment">// main_bus ports</span></span><br><span class="line">        <span class="variable">.bus</span>(bus), <span class="comment">// interface connection   main_bus connections</span></span><br><span class="line">        <span class="comment">// other ports</span></span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN),</span><br><span class="line">        <span class="variable">.test_mode</span>(test_mode)</span><br><span class="line">    );</span><br><span class="line">    instruction_reg ir (</span><br><span class="line">        <span class="variable">.program_address</span>(program_address),</span><br><span class="line">        <span class="variable">.instruction</span>(instruction),</span><br><span class="line">        <span class="variable">.jump_address</span>(jump_address),</span><br><span class="line">        <span class="variable">.next_instruction</span>(next_instruction),</span><br><span class="line">        <span class="variable">.clock</span>(clock),</span><br><span class="line">        <span class="variable">.resetN</span>(resetN)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* Module Definitions ********************/</span></span><br><span class="line"><span class="keyword">module</span> processor (</span><br><span class="line">    <span class="comment">// main_bus interface port</span></span><br><span class="line">    main_bus bus, <span class="comment">// interface port  each module definition has a single port for main_bus</span></span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] jump_address,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> resetN,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> test_mode</span><br><span class="line">);</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> slave (</span><br><span class="line">    <span class="comment">// main_bus interface port</span></span><br><span class="line">    main_bus bus, <span class="comment">// interface port     main_bus port declaration</span></span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> resetN</span><br><span class="line">    );</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dual_port_ram (</span><br><span class="line">    <span class="comment">// main_bus interface port</span></span><br><span class="line">    main_bus bus, <span class="comment">// interface port  main_bus port declaration</span></span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] program_address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] data_b</span><br><span class="line">    );</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> test_generator (</span><br><span class="line">    <span class="comment">// main_bus interface port</span></span><br><span class="line">    main_bus bus, <span class="comment">// interface port main_bus port declaration</span></span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> resetN,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> test_mode</span><br><span class="line">    );</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> instruction_reg (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] program_address,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] jump_address,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] next_instruction,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> resetN</span><br><span class="line">    );</span><br><span class="line">    ... <span class="comment">// module functionality code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例 10-2 中，设计的主要模块之间共有的所有信号都被封装到一个位置——称为 main_bus 的接口声明。顶层模块和构成这些块的所有模块不会重复声明这些公共信号。相反，这些模块只是使用接口作为它们之间的连接。</p>
<p>将通用信号封装到单个位置消除了 Verilog 模块的冗余声明。事实上，在前面的例子中，由于clock和resetN 对所有模块都是通用的，这些信号也可以被带入接口。 这种进一步的简化将在本章后面的第 274 页的示例 10-3 中显示。</p>
<h4 id="SystemVerilog-interface-内容"><a href="#SystemVerilog-interface-内容" class="headerlink" title="SystemVerilog interface 内容"></a>SystemVerilog interface 内容</h4><p><strong>接口可以包含功能</strong></p>
<p>SystemVerilog 接口不仅仅是一束电线。接口可以封装设计块之间通信的全部细节。使用接口：</p>
<ul>
<li>用于通信的离散信号和端口可以在一个位置定义，即接口。</li>
<li>可以在接口中定义通信协议。 </li>
<li>协议检查和其他验证例程可以直接内置到接口中。</li>
</ul>
<p><strong>接口消除了多余的声明</strong></p>
<p>使用 Verilog，必须在共享总线或其他通信架构的每个模块中复制通信细节。 SystemVerlog 允许在单个公共位置定义有关通信架构和架构使用的所有信息。接口可以包含类型声明、任务、函数、过程块、程序块和断言。 SystemVerilog 接口还允许定义接口的多个视图。例如，对于连接到接口的每个模块，data_bus 信号可以定义为输入、输出或双向端口。 SystemVerilog 接口的所有这些功能在本章的以下部分中进行了更详细的描述</p>
<h4 id="模块和接口的区别"><a href="#模块和接口的区别" class="headerlink" title="模块和接口的区别"></a>模块和接口的区别</h4><p><strong>接口与模块不同</strong></p>
<p>接口与模块存在三个根本区别:</p>
<ul>
<li>首先，界面不能包含设计层次结构。与模块不同，接口不能包含会创建新的实现层次结构的模块或原语的实例。</li>
<li>其次，接口可以用作模块端口，它允许接口表示模块之间的通信通道。在端口列表中使用模块是非法的。</li>
<li>第三，接口可以包含 modports，它允许连接到接口的每个模块以不同的方式查看接口。 Modports 在第 281 页的 10.6 节中有详细描述。</li>
</ul>
<h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><p><strong>接口的定义方式与模块类似</strong></p>
<p>从语法上讲，接口的定义与模块的定义非常相似。一个接口可以有端口，就像一个模块一样。这允许将接口外部的信号（例如时钟或复位线）引入接口并成为接口表示的信号束的一部分。接口还可以包含任何 Verilog 或 SystemVerilog 类型的声明，包括所有变量类型、所有网络类型和用户定义类型。</p>
<p>例 10-3 显示了一个名为 main_bus 的接口的定义，三个外部信号进入该<strong>interface</strong>：clock、resetN 和 test_mode。这些外部信号现在可以通过接口连接到每个模块，而无需明确地将信号连接到每个模块。请注意，在此示例中，接口 main_bus 的实例如何将时钟、resetN 和 test_mode 信号连接到它，使用与将信号连接到模块实例相同的语法。</p>
<p>Example 10-3: The interface definition for main_bus, with external inputs</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* Interface Definitions *******************/</span></span><br><span class="line"><span class="keyword">interface</span> main_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data; </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] slave_instruction;</span><br><span class="line">    <span class="keyword">logic</span> slave_request;</span><br><span class="line">    <span class="keyword">logic</span> bus_grant;</span><br><span class="line">    <span class="keyword">logic</span> bus_request;</span><br><span class="line">    <span class="keyword">logic</span> slave_ready;</span><br><span class="line">    <span class="keyword">logic</span> data_ready;</span><br><span class="line">    <span class="keyword">logic</span> mem_read;</span><br><span class="line">    <span class="keyword">logic</span> mem_write;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"><span class="comment">/********************** Top-level Netlist ********************/</span></span><br><span class="line"><span class="keyword">module</span> top (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] program_address, jump_address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction, next_instruction;</span><br><span class="line">	</span><br><span class="line">    main_bus bus ( <span class="comment">// instance of an interface</span></span><br><span class="line">        			<span class="comment">//discrete signals are connected to the interface instance</span></span><br><span class="line">		<span class="variable">.clock</span>(clock), </span><br><span class="line">        <span class="variable">.resetN</span>(resetN),</span><br><span class="line">        <span class="variable">.test_mode</span>(test_mode) </span><br><span class="line">    );</span><br><span class="line">processor proc1 (</span><br><span class="line">    <span class="comment">// main_bus ports</span></span><br><span class="line">    <span class="variable">.bus</span>(bus), <span class="comment">// interface connection</span></span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    <span class="comment">//discrete signals do not need to be connected to each design block instance</span></span><br><span class="line">    <span class="variable">.jump_address</span>(jump_address),</span><br><span class="line">    <span class="variable">.instruction</span>(instruction) </span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/*** remainder of netlist and module definitions are not ***/</span></span><br><span class="line"><span class="comment">/*** listed — they are similar to example 10-2, but ***/</span></span><br><span class="line"><span class="comment">/*** clock and resetN do not need to be passed to each ***/</span></span><br><span class="line"><span class="comment">/*** module instance as discrete ports. ***/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><em>接口实例可以使用 .name 和 .</em> 连接</em>*</p>
<p>SystemVerilog 简化的 .name 和 .* 端口连接样式也可用于接口端口连接。这些结构在第 233 页的第 9.4 节中进行了介绍。通过将接口的使用与 .* 端口连接的使用结合起来，可以使前面的示例更加简洁。这在下面的示例 10-4 中进行了说明。</p>
<p>Example 10-4: Using interfaces with  .* connections to simplify complex netlists</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* Interface Definitions *******************/</span></span><br><span class="line"><span class="keyword">interface</span> main_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] slave_instruction;</span><br><span class="line">    <span class="keyword">logic</span> slave_request;</span><br><span class="line">    <span class="keyword">logic</span> bus_grant;</span><br><span class="line">    <span class="keyword">logic</span> bus_request;</span><br><span class="line">    <span class="keyword">logic</span> slave_ready;</span><br><span class="line">    <span class="keyword">logic</span> data_ready;</span><br><span class="line">    <span class="keyword">logic</span> mem_read;</span><br><span class="line">    <span class="keyword">logic</span> mem_write;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************** Top-level Netlist ********************/</span></span><br><span class="line"><span class="keyword">module</span> top (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode);</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] program_address, jump_address;</span><br><span class="line">    <span class="keyword">logic</span> [ <span class="number">7</span>:<span class="number">0</span>] instruction, next_instruction, data_b;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//.* port connections can significantly reduce a netlist (compare to netlist in  example 10-2 on page 270).</span></span><br><span class="line">    main_bus bus ( .* );</span><br><span class="line">    processor proc1 ( .* ); </span><br><span class="line">    slave slave1 ( .* );</span><br><span class="line">    instruction_reg ir ( .* );</span><br><span class="line">    test_generator test_gen ( .* ); </span><br><span class="line">    dual_port_ram ram ( .*, <span class="variable">.data_b</span>(next_instruction) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">/*** remainder of netlist and module definitions are not ***/</span></span><br><span class="line"><span class="comment">/*** listed — they are similar to example 10-2, but ***/</span></span><br><span class="line"><span class="comment">/*** clock and resetN do not need to be passed to each ***/</span></span><br><span class="line"><span class="comment">/*** module instance as discrete ports.</span></span><br></pre></td></tr></table></figure>

<p><strong>SystemVerilog 极大地简化了网表</strong></p>
<p>在第 264 页的示例 10-1 中列出的这个简单示例的 Verilog 版本中，顶层网表模块顶部需要 65 行代码，不包括空白行和注释。使用 SystemVerilog 接口和 .*，上面的示例 10-4，只需要 10 行代码（不包括空白行和注释）来模拟相同的连接性。</p>
<h4 id="源代码声明顺序"><a href="#源代码声明顺序" class="headerlink" title="源代码声明顺序"></a>源代码声明顺序</h4><p><strong>接口名称可以在定义之前使用</strong></p>
<p>接口的名称可以在两种上下文中引用：</p>
<ul>
<li>在模块的端口中，</li>
<li>在接口的实例中。</li>
</ul>
<p>接口可以用作模块端口，而无需考虑文件顺序依赖性。与模块一样，在软件工具读入包含接口定义的源代码之前，可以引用接口的名称。这意味着任何模块都可以将接口用作模块端口，而无需考虑源代码的编译顺序。</p>
<h4 id="全局和本地接口定义"><a href="#全局和本地接口定义" class="headerlink" title="全局和本地接口定义"></a>全局和本地接口定义</h4><p><strong>接口可以是全局声明</strong></p>
<p>可以使用关键字 <strong>interface</strong> 和 <strong>endinterface</strong> 将接口与模块定义分开定义。接口的名称将在全局模块定义名称范围内，就像模块名称一样。这允许接口定义被设计层次结构中的任何模块用作端口。</p>
<p><strong>接口可以限制在特定的层次结构范围内</strong></p>
<p>接口定义可以嵌套在模块中，使接口的名称成为该模块的本地名称。只有包含模块才能实例化本地声明的接口。这允许接口的使用仅限于设计层次结构的一部分，例如仅限于 IP 模型内。</p>
<h3 id="使用接口作为模块端口"><a href="#使用接口作为模块端口" class="headerlink" title="使用接口作为模块端口"></a>使用接口作为模块端口</h3><p>使用 SystemVerilog，可以将模块的端口声明为<strong>interface</strong>类型，而不是 Verilog  <strong>input</strong>、<strong>output</strong>或<strong>inout</strong>端口方向</p>
<h4 id="显式命名的接口端口"><a href="#显式命名的接口端口" class="headerlink" title="显式命名的接口端口"></a>显式命名的接口端口</h4><p><strong>模块端口可以是接口的名称</strong></p>
<p>模块端口可以显式声明为特定类型的接口。这是通过使用接口名称作为端口类型来完成的。语法是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module &lt;module_name&gt; (&lt;interface_name&gt; &lt;port_name&gt;);</span></span><br><span class="line"><span class="comment">//For example:</span></span><br><span class="line"><span class="keyword">interface</span> chip_bus;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> CACHE (chip_bus pins, <span class="comment">// interface port</span></span><br><span class="line"><span class="keyword">input</span> clock);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显式命名的接口端口只能连接到同名的接口。如果任何其他接口定义连接到端口，则会发生错误。明确命名的接口端口可确保永远不会无意中将错误的接口连接到该端口。明确命名可以连接到端口的接口类型还可以在端口声明中直接记录端口的使用方式。</p>
<h4 id="通用接口端口"><a href="#通用接口端口" class="headerlink" title="通用接口端口"></a>通用接口端口</h4><p><strong>可以使用 interface 关键字声明端口</strong></p>
<p>通用接口端口使用关键字 interface 定义端口类型，而不是使用特定接口类型的名称。语法是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;module_name&gt; (<span class="keyword">interface</span> &lt;port_name&gt;);</span><br></pre></td></tr></table></figure>

<p>当模块被实例化时，任何接口都可以连接到通用接口端口。这提供了灵活性，因为同一模块可以以多种方式使用，不同的接口连接到模块。在以下示例中，模块 RAM 使用通用接口端口定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RAM (<span class="keyword">interface</span> pins,</span><br><span class="line">			<span class="keyword">input</span> clock);</span><br><span class="line">	... </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="综合指南-5"><a href="#综合指南-5" class="headerlink" title="综合指南"></a>综合指南</h4><p>两种将接口连接到模块的方式都是可以综合的。</p>
<h3 id="实例化和连接接口"><a href="#实例化和连接接口" class="headerlink" title="实例化和连接接口"></a>实例化和连接接口</h3><p><strong>接口的实例化方式与模块相同</strong></p>
<p>接口实例使用端口连接连接到模块实例的端口，就像离散网络连接到模块实例的端口一样。这要求接口和它所连接的模块都被实例化。</p>
<p>Interface实例的语法与模块实例的语法相同。如果接口的定义有端口，那么可以使用端口顺序连接样式或命名端口连接样式将信号连接到接口实例，就像使用模块实例一样。</p>
<p><strong>接口连接规则</strong></p>
<p><strong>注意</strong>：It is illegal to leave an interface port unconnected.</p>
<p><strong>interface ports must be connected</strong></p>
<p>module <strong>input</strong>、<strong>output</strong>或<strong>inout</strong>端口可以在模块实例上保持未连接状态。对于<strong>interface</strong>端口，情况并非如此。声明为<strong>interface</strong>的端口，无论是通用的还是显式的，都必须连接到<strong>interface</strong>实例或另一个<strong>interface</strong>端口。如果<strong>interface</strong>端口未连接，则会发生错误。</p>
<p>在模块实例上，已声明为接口类型的端口必须连接到接口实例或层次结构中更高的另一个接口端口。如果端口声明具有显式命名的接口类型，则它必须连接到相同类型的接口实例。如果端口声明具有通用接口类型，则它可以连接到任何类型的接口实例。</p>
<p>SystemVerilog <strong>.name</strong> 和 <strong>.</strong>* 端口连接样式也可用于<strong>interface</strong>实例，如第 275 页的示例 10-4 所示。这些端口连接样式在第 233 页的第 9.4 节中讨论。</p>
<p><strong>连接到接口实例的接口</strong></p>
<p>一个接口的端口可以连接到另一个接口</p>
<p>接口的端口也可以定义为接口。此功能允许一个接口连接到另一个接口。例如，设计的主总线可能有一个或多个子总线。主总线及其子总线都可以建模为接口。子总线接口可以表示为主接口的端口。</p>
<h3 id="在接口内引用信号"><a href="#在接口内引用信号" class="headerlink" title="在接口内引用信号"></a>在接口内引用信号</h3><p><strong>使用端口名称引用接口中的信号</strong></p>
<p>在具有接口端口的模块中，必须使用端口名称访问接口内的信号，使用以下语法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;port_name&gt;.&lt;internal_interface_signal_name&gt;</span><br></pre></td></tr></table></figure>

<p>在第 274 页的示例 10-3 中，main_bus 的接口定义包含时钟和 resetN 的声明。从模块有一个接口端口，端口名称为bus。从模型可以通过将其引用为 bus.clock 来访问接口内的时钟变量。例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> bus<span class="variable">.clock</span>, <span class="keyword">negedge</span> bus<span class="variable">.resetN</span>)</span><br><span class="line">	... </span><br></pre></td></tr></table></figure>

<p>示例 10-5 列出了模块从站的部分代码。该模型包含几个对 main_bus 接口中信号的引用。</p>
<p>Example 10-5: Referencing signals within an interface</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> slave (</span><br><span class="line">    <span class="comment">// main_bus interface port</span></span><br><span class="line">    main_bus bus</span><br><span class="line">    <span class="comment">// other ports</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// internal signals </span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] slave_data, slave_address;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] operand_A, operand_B;</span><br><span class="line">    <span class="keyword">logic</span> mem_select, read, write;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> bus<span class="variable">.address</span> = mem_select? slave_address: ’z;</span><br><span class="line">    <span class="keyword">assign</span> bus<span class="variable">.data</span> = bus<span class="variable">.slave_ready</span>? slave_data: ’z;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] &#123;	RESET = <span class="number">5&#x27;b00001</span>,</span><br><span class="line">                    	START = <span class="number">5&#x27;b00010</span>,</span><br><span class="line">                        REQ_DATA = <span class="number">5&#x27;b00100</span>,</span><br><span class="line">                        EXECUTE = <span class="number">5&#x27;b01000</span>,</span><br><span class="line">                        DONE = <span class="number">5&#x27;b10000</span>&#125; State, NextState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> bus<span class="variable">.clock</span>, <span class="keyword">negedge</span> bus<span class="variable">.resetN</span>) <span class="keyword">begin</span>: FSM</span><br><span class="line">        <span class="keyword">if</span> (!bus<span class="variable">.resetN</span>) State &lt;= START;</span><br><span class="line">        <span class="keyword">else</span> State &lt;= NextState;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span> : FSM_decode</span><br><span class="line">    	<span class="keyword">unique</span> <span class="keyword">case</span> (State)</span><br><span class="line">    		START: <span class="keyword">if</span> (!bus<span class="variable">.slave_request</span>) <span class="keyword">begin</span></span><br><span class="line">                        bus<span class="variable">.bus_request</span> = <span class="number">0</span>;</span><br><span class="line">                        NextState = State;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        operand_A = bus<span class="variable">.data</span>;</span><br><span class="line">                        slave_address = bus<span class="variable">.address</span>;</span><br><span class="line">                        bus<span class="variable">.bus_request</span> = <span class="number">1</span>;</span><br><span class="line">                        NextState = REQ_DATA;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">    	... <span class="comment">// decode other states</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span>: FSM_decode</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>注意： Use short names for the names of interface ports.</strong></p>
<p>由于interface中的信号是通过将interface端口名称附加到信号名称来访问的，因此使用短名称作为interface端口名称很方便。这使对interface信号名称的引用保持简短且易于阅读。与任何 Verilog 模块中一样，interface中的名称可以是描述性的和有意义的。</p>
<h3 id="Interface-modports"><a href="#Interface-modports" class="headerlink" title="Interface modports"></a>Interface modports</h3><p><strong>interface</strong>提供了一种实用且直接的方式来简化模块之间的连接。但是，连接到接口的每个模块可能需要查看接口内连接的稍微不同的视图。例如，对于总线上的从机， Interrupt_request 信号可能是从机的输出，而对于同一总线上的处理器，interrupt_request 可能是输入。</p>
<p><strong>modports 从模块的角度定义接口连接</strong></p>
<p>SystemVerilog 接口提供了一种方法来定义每个模块在其接口端口上看到的接口信号的不同视图。使用 <strong>modport</strong> 关键字在接口内进行定义。 <strong>Modport</strong> 是模块端口的缩写。 modport 定义描述了由接口表示的模块端口。一个接口可以有任意数量的 modport 定义，每一个都描述一个或多个其他模块如何查看接口内的信号。</p>
<p>modport 定义了模块在接口中看到的信号的端口方向。两个 <strong>modport</strong> 声明的示例是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> chip_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">                    <span class="keyword">logic</span> interrupt_request, grant, ready;</span><br><span class="line">                    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] address;</span><br><span class="line">                    <span class="keyword">wire</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">modport</span> master (<span class="keyword">input</span> interrupt_request,</span><br><span class="line">                    <span class="keyword">input</span> address,</span><br><span class="line">                    <span class="keyword">output</span> grant, ready,</span><br><span class="line">                    <span class="keyword">inout</span> data,</span><br><span class="line">                    <span class="keyword">input</span> clock, resetN);</span><br><span class="line">    <span class="keyword">modport</span> slave (<span class="keyword">output</span> interrupt_request,</span><br><span class="line">                    <span class="keyword">output</span> address,</span><br><span class="line">                    <span class="keyword">input</span> grant, ready,</span><br><span class="line">                    <span class="keyword">inout</span> data,</span><br><span class="line">                    <span class="keyword">input</span> clock, resetN);</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p><strong>modport</strong> 定义不包含向量大小或类型。此信息被定义为接口中信号类型声明的一部分。 <strong>modport</strong> 声明仅定义连接模块是否将信号视为<strong>input</strong>, <strong>output</strong>,  bidirectional <strong>inout</strong>, or <strong>ref</strong> port。</p>
<h4 id="指定要使用的-modport-视图"><a href="#指定要使用的-modport-视图" class="headerlink" title="指定要使用的 modport 视图"></a>指定要使用的 modport 视图</h4><p>SystemVerilog 提供了两种方法来指定模块接口端口应该使用哪个 modport 视图：</p>
<ul>
<li>作为与模块实例的接口连接的一部分</li>
<li>作为模块定义中模块端口声明的一部分</li>
</ul>
<p>这两种规范风格都是可综合的。</p>
<h5 id="在模块实例中选择-modport"><a href="#在模块实例中选择-modport" class="headerlink" title="在模块实例中选择 modport"></a>在模块实例中选择 modport</h5><p>modport 可以在模块实例中选择</p>
<p>当一个模块被实例化并且一个接口的实例连接到一个模块实例端口时，可以指定该接口的具体modport。与 modport 的连接指定为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface_instance_name&gt;.&lt;modport_name&gt;</span><br></pre></td></tr></table></figure>

<p>For example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chip_bus bus; <span class="comment">// instance of an interface</span></span><br><span class="line">primary i1 (bus<span class="variable">.master</span>); <span class="comment">// use master modport</span></span><br></pre></td></tr></table></figure>

<p>以下代码片段说明了将两个模块与一个名为 chip_bus 的<strong>interface</strong>连接在一起。名为primary的模块连接到接口的master视图，名为secondary的模块连接到同一个接口的slave视图：</p>
<p>Example 10-6: Selecting which modport to use at the module instance</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> chip_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    <span class="keyword">modport</span> master (...);</span><br><span class="line">    <span class="keyword">modport</span> slave (...);</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> primary (<span class="keyword">interface</span> pins); <span class="comment">// generic interface port</span></span><br><span class="line">	... </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">module</span> secondary (chip_bus pins); <span class="comment">// specific interface port</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">module</span> chip (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    chip_bus bus (clock, resetN); 	<span class="comment">// instance of an interface</span></span><br><span class="line">    primary i1 (bus<span class="variable">.master</span>); 		<span class="comment">// use the master modport view</span></span><br><span class="line">    secondary i2 (bus<span class="variable">.slave</span>); 		<span class="comment">// use the slave modport view</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>当在模块实例中指定要使用的 <strong>modport</strong> 时，模块定义可以使用通用接口端口类型或显式命名的接口端口类型，如第 278 页的 10.3.2 节和第 277 页的 10.3.1 节所述. 前面的示例显示了主模块的通用接口端口定义，以及辅助模块的明确命名的端口类型。</p>
<h5 id="在模块端口声明中选择-modport"><a href="#在模块端口声明中选择-modport" class="headerlink" title="在模块端口声明中选择 modport"></a>在模块端口声明中选择 modport</h5><p><strong>modport 可以在模块定义中选择</strong></p>
<p>要使用的接口的特定 modport 可以直接指定为模块端口声明的一部分。要连接到接口的 modport 指定为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface_name&gt;.&lt;modport_name&gt;</span><br></pre></td></tr></table></figure>

<p>For example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> secondary (chip_bus<span class="variable">.slave</span> pins);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>当要使用的 modport 被指定为模块定义的一部分时，必须在端口类型中指定显式接口名称。模块实例只是将接口实例连接到模块端口，而不指定模块端口的名称。以下代码片段显示了指定将哪个 modport 连接到模块的更完整上下文，作为模块定义的一部分。</p>
<p>Example 10-7: Selecting which modport to use at the module definition</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> chip_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    <span class="keyword">modport</span> master (...);</span><br><span class="line">    <span class="keyword">modport</span> slave (...);</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> primary (chip_bus<span class="variable">.master</span> pins); <span class="comment">// use master modport</span></span><br><span class="line">	... </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> secondary (chip_bus<span class="variable">.slave</span> pins); <span class="comment">// use slave modport</span></span><br><span class="line">	... </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> chip (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN);</span><br><span class="line">    chip_bus bus (clock, resetN); <span class="comment">// instance of an interface</span></span><br><span class="line">    primary i1 (bus); <span class="comment">// will use the master modport view</span></span><br><span class="line">    secondary i2 (bus); <span class="comment">// will use the slave modport view</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：可以在模块实例或模块定义中选择 modport，但不能同时选择两者。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/12/kicad-note/" rel="prev" title="kicad_note">
                  <i class="fa fa-chevron-left"></i> kicad_note
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/11/hello-world/" rel="next" title="Hello World">
                  Hello World <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zsz</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
